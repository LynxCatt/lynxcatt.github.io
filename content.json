{"posts":[{"title":"二分图与图的连通","text":"update: 2023/12/12 fixed pictures Week 1——C++，启动！1. 学习内容本周学习内容： 123456789101112131415161718192021222324252627282930313233343536Week 1|- 二分图| |- 二分图的判定| | |- 染色法| | |- 不存在奇环（长为奇数的环）| |- 二分图最大匹配（匈牙利算法）| |- 二分图最小点覆盖（König定理二分：二分图中，最小点覆盖=最大匹配）| |- 二分图最大独立集（二分图中，最大独立集=n-最小点覆盖）| |- 例题（关于建边）|- 图的联通| |- 定义（只有概念，详细定义见下）| | |- 无向图中的定义| | | |- 连通图| | | |- 子图| | | |- 连通子图| | | |- 连通分量（最大联通子图）| | |- 有向图中的定义| | | |- 强连通图| | | |- 强连通子图| | | |- 强连通分量| | | |- k连通图（双连通图）| | | |- 割点| | | |- 桥| | | |- 双连通分量| | | |- 点双连通分量| | | |- 边双连通分量| |- 算法| | |- 如何求强连通分量（SCC）= 如何缩点| | | |- Kosaraju算法| | | |- Tarjan算法| | | |- Gabow算法（略）| | |- 如何求桥/割点| | | |- Tarjan算法（对还是它）| | |- 如何求点/边双连通分量| | | |- Tarjan算法（啊？） 2. 学习内容的模板（以及图论常用模板）二分图最大匹配（König算法）例题12345678910111213141516171819202122232425vector&lt;int&gt; g[MAXN];bool vis[MAXM];int lst[MAXM];bool konig(int u) { for (auto &amp;v : g[u]) { // auto好用的 if (vis[v]) continue; vis[v] = 1; if (lst[v] == 0 || findargu(lst[v])) { lst[v] = u; return 1; } } return 0;}int main() { int cnt = 0; for (int i = 1; i &lt;= n; i++) { memset(vis, 0, sizeof vis); // 打时间戳可以优化常数 if (findargu(i)) cnt++; } cout &lt;&lt; cnt;} 强连通分量（SCC）以及缩点（包含建新图）例题（附带最短路）123456789101112131415161718192021222324252627282930313233343536373839404142vector&lt;int&gt; g[MAXN];int dfn[MAXN], low[MAXN], dfncnt; // 两个关键数组：dfn, lowbool ins[MAXN];int st[MAXN], top; // 手写栈int tag[MAXN], tagcnt; // 标记数组，tagcnt是强连通分量的个数void tarjan(int u) { dfn[u] = low[u] = ++dfncnt; ins[u] = 1; st[++top] = u; for (auto &amp;v : g[u]) { if (!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else if (ins[v]) low[u] = min(low[u], dfn[v]); } if (dfn[u] == low[u]) { tagcnt++; while (1) { int v = st[top--]; ins[v] = 0; tag[v] = tagcnt; if (v == u) break; } }}int main() { // 因为不确定图是否连通，所以对于每一个点都要跑一遍Tarjan for (int i = 1; i &lt;= n; i++) { if (!dfn[i]) tarjan(i); } // 缩点(建新图) vector&lt;int&gt; h[MAXN]; for (int i = 1; i &lt;= m; i++) { if (tag[e[i].u] != tag[e[i].v]) { h[tag[e[i].u]].push_back(tag[e[i].v]); } }} 割点 例题123456789101112131415161718192021222324252627vector&lt;int&gt; g[MAXN];int dfn[MAXN], low[MAXN], dfncnt;int tag[MAXN], tagcnt; // 求割点不需要使用栈// 割点bool cut[MAXN]; // 标记那些点是割点int cnt; // 统计割点个数void tarjan(int u, int f) { dfn[u] = low[u] = ++dfncnt; int sons = 0; for (auto &amp;v : g[u]) { if (!dfn[v]) { tarjan(v, u); sons++; low[u] = min(low[u], low[v]); if (low[v] &gt;= dfn[u] &amp;&amp; !cut[u] &amp;&amp; u != rt) { // 割点的判断-1 cut[u] = 1; cnt++; } } else if (dfn[v] &lt; dfn[u] &amp;&amp; v != f) low[u] = min(low[u], dfn[v]); } if (u == rt &amp;&amp; sons &gt;= 2 &amp;&amp; !cut[u]) { // 割点的判断-2 cut[u] = 1; cnt++; }} 桥 例题（没有例题，不要点开）1234567891011121314151617181920vector&lt;int&gt; g[MAXN];int dfn[MAXN], low[MAXN], dfncnt;int tag[MAXN], tagcnt; // 求桥还是不需要使用栈// 桥（输出到stdout）void tarjan(int u, int f) { dfn[u] = low[u] = ++dfncnt; int sons = 0; for (auto &amp;v : g[u]) { if (!dfn[v]) { tarjan(v, u); sons++; low[u] = min(low[u], low[v]); if (low[v] &gt; dfn[u]) { // 桥的判断 cout &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; endl; } } else if (dfn[v] &lt; dfn[u] &amp;&amp; v != f) low[u] = min(low[u], dfn[v]); }} 点双连通分量 例题123456789101112131415161718192021222324252627282930313233int dfn[MAXN], low[MAXN], dfncnt;int tag[MAXN], tagcnt;stack&lt;int&gt; st;int rt;vector&lt;int&gt; ans[MAXN];int cnt;void tarjan(int u) { dfn[u] = low[u] = ++dfncnt; st.push(u); if (u == rt &amp;&amp; !head[u]) { // 判断孤立点 ans[++cnt].push_back(u); return ; } for (int i = head[u]; i; i = g[i].nxt) { // 这里使用链式前向星 int v = g[i].to; if (!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); if (low[v] &gt;= dfn[u]) { cnt++; int p; do { p = st.top(); st.pop(); ans[cnt].push_back(p); } while (v != p); ans[cnt].push_back(u); } } else low[u] = min(low[u], dfn[v]); }} dijkstra算法 例题0 例题1 例题2 （例题0是板子，例题1-2是缩点+最短路）1234567891011121314151617181920212223242526272829303132// 值得注意的一点是，dijkstra算法处理最长路时会损失效率（虽然可以卡过），所以在处理最长路时使用SPFA会更加有效（尽管它死了）// 上述内容对应例题2，如果使用dijkstra算法的话会WA#3struct node{ int dis, u; bool operator &lt; (const node&amp; a) const { return dis &gt; a.dis; }};bool vis[MAXN];int dis[MAXN];priority_queue&lt;node&gt; q;void dijkstra(int s) { memset(dis, 0x3f, sizeof dis); dis[s] = 0; q.push({0, s}); while (!q.empty()) { int u = q.top().u; q.pop(); if (vis[u]) continue; vis[u] = 1; for (auto &amp;i : h[u]) { int v = i.first, w = i.second; if (dis[v] &gt; dis[u]+w) { dis[v] = dis[u]+w; q.push({dis[v], v}); } } }} SPFA算法 例题0 例题1 （例题0是板子，例题1是缩点+最短路）1234567891011121314151617181920212223242526272829303132// SPFA尽管死了并且它的效率要比dijkstra慢，但是其拥有良好的负环检测系统，关键是：最长路能用vector&lt;int&gt; h[500010];int dis[500010], cnt[500010];bool vis[500010];queue&lt;int&gt; q;// 这是最长路并且统计的是点权，改为最短路/统计边权只要参考dijhstra就好bool spfa() { memset(dis, -1, sizeof dis); // 最短路需改 int f = tag[s]; q.push(f); dis[f] = mon[f]; vis[f] = 1; while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (auto &amp;i : h[u]) { if (dis[i] &lt; dis[u]+mon[i]) { // 最短路/统计边权需改 dis[i] = dis[u]+mon[i]; // 最短路/统计边权需改 cnt[i] = cnt[u]+1; if (cnt[i] &gt;= tagcnt) return 0; if (!vis[i]) { q.push(i); vis[i] = 1; } } } } return 1;} 3. 学习内容——各种定义强连通/连通图在无向图中，任意两点都直接或间接连通，则称该图为 连通图(connected). 相应的，有向图中任意一点都存在路径到达任意另一点，则称该有向图为 强连通图(strong connected) . 子图在一个图 $H$ 中，$H$ 的所有边属于图 $G$ 的所有边，$H$ 的所有点属于图 $G$ 的所有点，则称图 $H$ 是图 $G$ 的 子图(subgraph) . 连通分量无向图 $G$ 的最大连通子图称为 $G$ 的 连通分量(connected components) . 何为最大连通子图？这个子图是 $G$ 的连通子图，将 $G$ 的任何一个不在这张子图中的点加入这张子图后，该子图不再连通. 强连通分量（SCC）在任意有向图中能够实现强连通的部分我们称其为 **强连通分量(Strongly connected component)**，如下图，蓝色框内的分别是一个强连通分量. 如果把每个强连通分量收缩为单个顶点，得到的是一个 **有向无环图(DAG)**，于是我们可以在这个图的基础上进行拓扑排序，详见此例题. 而求这个强连通分量，我们可以使用两个算法：Kosaraju算法，Tarjan算法. Kosaraju算法的流程如下： 重复寻找图 $G$ 中未被讨论的点，从它开始DFS后序遍历图 $G$ ，遍历到的点置为已讨论，用数组记录每个点到达的先后次序，直到找不到没有讨论的点. 将图 $G$ 反向得到图 $G’$ ，重置所有点为未讨论. 一直从数组中未讨论的最后一个点出发，DFS后续遍历图 $G’$ ，DFS每完成一次，就说明找到了一个强连通分量，直到数组中没有未讨论的点. 这是Kosaraju算法的模板（之所以Kosaraju算法没有放在SCC的模板内，是因为这个算法相对于Tarjan算法少用很多）： 12345678910111213141516171819202122232425262728293031323334353637383940414243bool g[1001][1001]; // 这里使用的是邻接矩阵bool vis[1001];int lis[1001], cnt = 0;int tag[1001], scc = 0;bool ind[1001];void dfs1(int u) { vis[u] = 1; for (int i = 1; i &lt;= n; i++) { if (g[u][i] &amp;&amp; !vis[i]) dfs1(i); } lis[++cnt] = u;}void dfs2(int u) { vis[u] = 1; tag[u] = scc; for (int i = 1; i &lt;= n; i++) { if (g[i][u] &amp;&amp; !vis[i]) dfs2(i); // 这里注意，判断的边是g[i][u]，因为我们要在反图上跑dfs2() }}int main() { for (int i = 1; i &lt;= n; i++) vis[i] = 0; // 这里可以用memset for (int i = 1; i &lt;= n; i++) { if (!vis[i]) dfs1(i); } for (int i = 1; i &lt;= n; i++) vis[i] = 0; for (int i = cnt; i &gt;= 1; i--) { if (!vis[lis[i]]) { scc++; dfs2(lis[i]); } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if ((tag[i] != tag[j]) &amp;&amp; g[i][j]) { // 此处为缩点 } } }} 接下来我们来说说Tarjan算法，这个算法相对于上个算法理解起来要困难些. 在Tarjan算法中，最为重要的两个数组是 dfn[] 和 low[] ， dfn[i] 记录的是编号为i的节点在DFS的整个过程的顺序，它会在第一次访问到 $i$ 节点时更改，此后将不会变化；low[i] 表示的是 i 与其之后遍历到的节点所能到达的节点中 dfn 最小的 dfn ，在初始化时 dfn[i]=low[i] . Tarjan算法在运行时会生成一棵搜索树，但是我们知道，图!=树，因为图中有一些边会使得“树”有环，自然，在生成树后，有一些边会直接指向已遍历的节点，没遍历的节点会在下一步当作自己的孩子进行遍历，而指向已遍历节点的边就是导致“树”有环的罪魁祸首.按照定义，当发现有这种边的存在时，需要更新当前节点的 low[] 值，需要更新为 min(dfn[这些边指向的节点]) .而理所当然地，我们也要被孩子节点更新 low 值为 min(low[孩子节点]) . 现在我们聚焦某一个点 $i$，观察 dfn[i] 与 low[i] 的关系，以下是两种情况： dfn[i]&gt;low[i] ，这说明 $i$ 或其子孙节点存在边连到 $i$ 上方的节点. dfn[i]=low[i] ，这说明 $i$ 以及其子孙节点无法连到 $i$ 上方的节点，那么这个点 $i$ 就是一个强连通分量在这颗搜索树的根. 但是，$i$ 的子孙节点有可能会组成另一个强连通分量，这意味着 $i$ 的子树的节点不一定和 $i$ 处在同一个强连通分量内，我们需要 栈 来解决这个问题. 现在，我们用一张图看一下 dfn[] 与 low[] 的关系。 在这张图中，有 (3,4,5,6) ，7 ，8 ，1 ，2 这四个强连通块. 下图是Tarjan算法的运行过程. 因为SCC模板就是Tarjan算法，所以在这里不放代码. 二分图的最大匹配何为二分图？二分图是一种特殊的无向图，它的顶点可以被分为两个互斥的独立集 $U$ 和 $V$ 的图，使得所有边都是连结一个 $U$ 中的点和一个 $V$ 中的点（如下图所示）. 何为匹配？一个图的匹配是这个图中一些边所形成的集合，满足任意集合中的两条边都没有公共顶点. 解决这个问题的算法之一是匈牙利算法.在了解这个算法之前，我们先要了解一下何为增广路（增广轨/交错轨）. 增广路：若 $P$ 是图 $G$ 中一条连通两个未匹配顶点的路径，并且已匹配和未匹配的边（也就是属匹配边集 $M$ 的边和不属 $M$ 的边）在 $P$ 上交替出现，则称 $P$ 为相对于 $M$ 的一条增广路径. 不难发现，如果我们把 $P$ 中原来属于 $M$ 边从 $M$ 中删除，把 $P$ 中原来不属于 $M$ 边加入到 $M$ 中，变化后得到的新的匹配 $M’$ 恰好比原匹配多一条边. 而匈牙利算法就是不断寻找增广路 $P$ ，通过取反操作得到更大的匹配 $M’$ 来代替 $M$ . 代码如模板所示. 割点是无向连通图中一个顶点 $v$ , 如果删除它以及它关联的边后，得到的新图至少包含两个连通分量. 这里同样使用Tarjan算法. 思路和求SCC的Tarjan算法类似，这里直接给出结论： 一个顶点 $u$ 是割点，当且仅当满足条件 $1$ 或 $2$. $u$ 为树根，且 $u$ 有两棵及以上的子树（这很好理解吧）. $u$ 不为树根，且满足存在一条 $(u,v)$ 为树枝边使得 dfn[u] &lt;= low[v] ，即 $u$ 有一个孩子无法到达 $u$ 以上的点. 代码如模板所示. 桥是无向连通图中的一条边，如果删除它，得到的新图包含两个连通分量. 求桥和求割点差不多，可以直接从代码看出差别，而且判断条件的理解也和求割点差不多，此处不过多赘述. 双连通图不含割点的无向连通图. 双连通分量无向连通图的最大双连通子图. 点双连通分量通过找割点获得的双连通分量（层层递进.jpg 边双连通分量 （模板没打）通过找桥获得的双连通分量. 4. 心得体会主要是图论之前有接触过，所以理解概念会比较快，同时在这一周我把之前一直没弄懂的Tarjan算法搞懂了. 现在的问题主要是建边的技巧以及破题的能力，像这种题（[SDOI2010]所驼门王的宝藏），这些建边的技巧想不到. 图论的常识有些遗忘了，例如Dijkstra跑最长路不能保证时间复杂度这类东西. 5. 常用网站收集路过图床 ImgTP 生成图 OI Wiki","link":"/2023/12/28/%E4%BA%8C%E5%88%86%E5%9B%BE%E4%B8%8E%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A/"},{"title":"区间DP总结","text":"考试总结Task 1正解性质题，找规律。 规律如下： 从 $n=15$ 开始：$108\\newline 188\\newline 200\\newline 208\\newline 288\\newline 688\\newline 888\\newline 1088\\newline 1888\\newline 2008\\newline 2888\\newline 8888\\newline \\dots$ 容易发现 $a_n=a_{n-7}\\times10+8\\quad(n \\geq 22)$ 前14个要特判。 代码1无 关键点暴力找规律。 死因20 开头的规律没找到，就是没打暴力找规律。 Task 2正解搜索。 优化这道题可以用 十字链表（Dancing Links X） 加速，但是爆搜就能跑出 $400\\text{ms}$ 的好成绩。 别名：双向循环十字链表。 为什么能跑这么快关键点： 对于这种搜索时间最不利的是 $5 \\times 6$ 的矩阵，并且是无解的情况。 正常来说，如果不要求不能重复走点，时间复杂度最坏为 $O(2^{4} \\times 3^{14} \\times 4^{16})$ ，即四个角（4个）上的点有两种走法，边上的点（14个）有三种走法，内部的点（16个）有四种走法。 但是不能重复走点的情况下，时间复杂度最坏为 $O(1^{4} \\times 2^{14} \\times 3^{16})$，但是考虑到实际情况，加一个可行性剪枝，最后 $\\text{dfs()}$ 函数大概只会运行到 $5 \\times 10^6$ 次。 爆搜敢冲就能过。 题目来源《永远的七日之都》 代码1无 死因1for (int i = 0; i &lt;= n; i++) // wssb Task 3正解以 $dp$ 为辅助的搜索题。 说真的，这道题不难。一切的思路都是自然而然的，从爆搜到可行性剪枝再到用 $dp$ 完成可行性剪枝，最后实现的代码难度也不高。 关键点$dp$ 可能不是一道题的全部而是一道题的部分。 思路 先想爆搜，同一位按字典序从大到小搜，期望得分：$30-40;pts$。 再想剪枝，用 $dp$ 判定后面有没有可能有解，计算一个点后最多能获取到的权值，再加上已经搜到的权值看它能不能 $\\geq x$ 。 怎么做 $dp$ ？记录 $dp$ 长度和最后一位，预处理 $dp$ 时间复杂度为 $O(4n)$ 。整个算法时间复杂度见课后思考。 课后思考 整体时间复杂度是 $O(n+k)$ 还是 $O(nk)$ ？理论分析应该是 $O(n+k)$ 。 代码1无 死因并没有死，打了暴力。还是全场唯一得分点（$30;pts$）。 但是事实上我的暴力打得还有优化空间且有一个小问题。 Task 4正解区间 $dp$ 。 思路 考虑朴素区间 $dp$ ，对于每个 $l\\sim r$ 区间，枚举小区间并转移，时间复杂度 $O(n^4)$ 。 但是这种做法会 $\\text{WA}$ 掉，因为这样记录状态会有情况没考虑到。所以考虑重设状态 $f_{i,j,max,min}$ 表示区间 $i\\sim j$ 内已经通过多次操作后剩下的最大值为 $max$ 、最小值为 $min$ 时，所花的最小代价。而后我们定义 $ans_{i,j}$ 为 $i\\sim j$ 这段区间被选空的最终答案（就是题目中说的那个最后输出的答案）。 接下来考虑怎么转移。$ans_{i,j}$ 的转移很简单，就是 $ans_{i,j}=max(f_{i,j,max,min}+a+b\\times(max-min))$ 。而 $f_{i,j,max,min}$ 的转移，首先应该枚举中间断点 $k$ 就应该有以下三种情况： $min$ 与 $max$ 都在左边，右边被选空：$f_{i,j,max,min}=f_{i,k,max,min}+ans_{k+1,j}$ 。 $min$ 与 $max$ 都在右边，左边被选空：$f_{i,j,max,min}=ans_{i,k}+f_{k+1,j,max,min}$ 。 $min$ 与 $max$ 左右两边都有：$f_{i,j,max,min}=f_{i,k,max,min}+f_{k+1,j,max,min}$ 。 容易发现的是，这样转移肯定不会少考虑情况，接下来就是考虑这么转移是否会多考虑情况？如果多考虑了，对答案有没有影响？ 【这里不会】（zhw看到了comment一下） 结论：会多考虑情况但是这些情况不会比答案更优。 注意点：$w_i \\leq 1000$ ，需要离散化处理。 来源THUSC 2016 成绩单 代码1无 区间DP总结 区间DP是变化之神！ $\\text{Link Start!}$ 简单的区间DP通过例题看看区间DP的一些套路和新的思路。 不如按题目分类来说。 A~E 普通/模板区间DP 能量项链——普通区间DP 石子合并（加强版）——四边形不等式优化（不要求掌握） 【USACO 3.3.5】A Game游戏 IOI’96——带了博弈论的区间DP（个人觉得有点意思） 做错的作业——括号匹配类型的区间DP 【CQOI 2007】涂色——涂色类型区间DP F,G 凸多边形区间DP这一类型的DP特点是建立模型比较难。 要点梳理： 无论从哪一个点开始都一样，因此不必拆环成链。 状态定义为：$f_{i,j}$ 表示将 $i\\sim j$ 这一段点的区间转化为三角形的最小价值。 状态转移为：$f_{i,j}=\\min(f_{i,j},f_{i,k}+f_{k,j}+\\text{cost}(i,j,k))$ ，即 $k$ 是两个子区间的公共端点， 而将他们合并后能组合出新的三角形 $\\Delta A_iA_jA_k$ ，因此要加上这个新三角形造成的权值。 H 字符串折叠我认为这道题的思路是捋得最清的，因为这道题真的很简单。 大致思路就是有两种转移：一是组合两段已压缩的区间，二是将这段区间压缩，时间复杂度大致为 $O(n^4)$ ，能刚刚好卡着过（据说用预处理或哈希或KMP找最长重复子串的长度能够将这道题卡到 $O(n^3)$ 的时间复杂度，然鹅我不会）。 R 压缩这也是一道压缩字符串的题目。 但是这里对 $M$ 和 $R$ 的处理要更为复杂。 具体而言，这道题的 $f_{i,j,k}\\quad(1\\leq i\\leq j\\leq n,k\\subset{0,1})$ 多了一维，用于标记 $i\\sim j$ 这段区间内是（$1$）否（$0$）存在 $M$ 。 状态转移： $f_{i,j,0}=f_{i,k,0}+j-k$ $f_{i,j,1}=\\min(f_{i,k,0},f_{i,k,1})+\\min(f_{k+1,j,0},f_{k+1,j,1})$ $f_{i,j,0}=f_{i,mid,0}+1\\quad\\text{when }[i,j]\\text{ can compress}$ J 表达式的亿种可能性最有意义的题目之一。 维护的 $f_{i,j}$ 就是答案所求，关键就在转移。 弄清楚以下几点： $\\times$ 的转移不需要别的东西，只需要 $f_{i,j}=f_{i,k}\\times f_{k+1,j} \\times\\text{val}$ $+$ 和 $-$ 的转移需要考虑左边的括号个数和右边的括号个数（详见第一次提交内的代码推导），最终转移式为：$f_{i,j}=((j-k-1)!f_{i,k}+(k-i)!f_{k+1,j})\\times\\text{val}$ 但是以上转移式只考虑了先放完左边的括号再放右边的括号，然而，我们可以左右交替来回放，并且，左边内括号的顺序已经是我们在 $f_{i,k}$ 中内定好的了。因此 $\\text{val}=\\frac{(j-i-1)!}{(k-i)!(j-k-1)!}$ 作为系数。 M 有味道的数字最具有启发性的一题。 这道题有几个性质需要搜索搜出来——只有 $3$ 和 $7$ 无法表示，表示 $5000$ 以内的数字最多只会用到长度为 $11$ 的前缀。 $f_{i,j}$ 表示 $i\\sim j$ 这段区间内能表示出来的值（是个数组）这种思想有个很NB的名字叫做 **离散_____**（人话：打表）。 即用 $\\text{vector}$ 存储值，单次转移时间复杂度就是 $O(nm)$ （ $n,m$ 表示合并的两个 $\\text{vector}$ ） ，玄学下降！ 而转移嘛……人人都会。 Q 单调栈搜索最上牌面的一题。 这道题思路没什么好说的，只是注意一下有的时候记忆化搜索比循环区间DP好写。 区间DP的一点小知识我个人一般会这么打区间DP： 123456for (int len = 2; len &lt;= n; len++) { for (int i = 1; i+len-1 &lt;= n; i++) { int j = i+len-1; // ... }} 然而这么打常数是比较大的，优化写法： 12345for (int j = 2; j &lt;= n; j++) { for (int i = j-1; i &gt;= 1; i--) { // ... }} 据说这样能优化很多。 我认为区间DP还有一类很重要的题，典型例题：关路灯 区间DP的特征 在操作中需要将两端区间合并，合并时存在固定的转移关系。 在操作中需要将子区间转移。 怎么看需不需要多开维数很明显，当目前的状态定义会出现明显重复统计或是限制条件不够时要多开空间。","link":"/2023/12/28/%E5%8C%BA%E9%97%B4DP%E6%80%BB%E7%BB%93/"},{"title":"分块与矩阵","text":"update: 2023/12/12 fixed pictures 本文中所有图片均使用Power Point制作 分块部分俗话说得好： ${ \\Huge 暴力+暴力=分块 }$ 分块总的来说就是线段树的阉割版，其时间复杂度基本维持在 $\\sqrt N$ 数量级。一般的分块支持单点/区间查询以及单点/区间修改. 分块的块长一般是 $\\sqrt N$ ( $N$ 是数组大小)，例如，对于一个数组 $A$ ，$|A| =13$ ，每一块的长度便是 $\\sqrt {13}\\approx3$ ，但是分块完成后我们会发现最后一块的大小是 $1$ ，不足其他块的大小(如下图). 分了块后我们便可以干很多事了，单点查询/修改就不说了，直接访问数组下标进行修改.我们来说说区间查询/修改，例如还是那个数组 $A$ ，现在我们要修改下标为 $2$ 到 $7$ 的区间，这个时候我们要对每一块生成一个懒标记，于是我们的思路便很明确了，对于这段区间里整块的部分直接修改懒标记，剩下的不足一整块暴力修改(如下图).同理，查询也是一样，只是要注意统计时要把所有懒标记加上，不管是整块还是不足整块.下面也会给出一份区间修改(增加)区间查询(最大值)的代码. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3fffffff;int n, m, s;int a[100100], chunk[100100], lazy[100100];void modify(int x, int y, int z) { int i = (x-1)/s+1; int j = (y-1)/s+1; chunk[i] = -inf; chunk[j] = -inf; if (i == j) { for (int k = x; k &lt;= y; k++) { a[k] += z; } for (int k = (i-1)*s+1; k &lt;= j*s; k++) { if (a[k] &gt; chunk[i]) chunk[i] = a[k]; } } else { for (int k = x; k &lt;= i*s; k++) { a[k] += z; } for (int k = (i-1)*s+1; k &lt;= i*s; k++) { if (a[k] &gt; chunk[i]) chunk[i] = a[k]; } for (int k = (j-1)*s+1; k &lt;= y; k++) { a[k] += z; } for (int k = (j-1)*s+1; k &lt;= j*s; k++) { if (a[k] &gt; chunk[j]) chunk[j] = a[k]; } for (int k = i+1; k &lt; j; k++) { lazy[k] += z; } }}int search(int x, int y) { int i = (x-1)/s+1; int j = (y-1)/s+1; int ans = -inf; if (i == j) { for (int k = x; k &lt;= y; k++) { if (a[k]+lazy[i] &gt; ans) ans = a[k]+lazy[j]; } } else { for (int k = x; k &lt;= i*s; k++) { if (a[k]+lazy[i] &gt; ans) ans = a[k]+lazy[i]; } for (int k = (j-1)*s+1; k &lt;= y; k++) { if (a[k]+lazy[j] &gt; ans) ans = a[k]+lazy[j]; } for (int k = i+1; k &lt; j; k++) { if (chunk[k]+lazy[k] &gt; ans) ans = chunk[k]+lazy[k]; } } return ans;}signed main() { scanf(&quot;%d&quot;, &amp;n); s = sqrt(n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, a+i); if (i%s == 1 || a[i] &gt; chunk[(i-1)/s+1]) chunk[(i-1)/s+1] = a[i]; } cin &gt;&gt; m; while (m--) { char op[3]; int x, y, z; scanf(&quot;%s%d%d&quot;, op, &amp;x, &amp;y); if (op[2] == 'D') { cin &gt;&gt; z; modify(x, y, z); } else { cout &lt;&lt; search(x, y) &lt;&lt; endl; } }}/*Input:51 2 3 2 55ADD 1 4 3ASK 2 3ASK 3 5ADD 2 4 2ASK 2 5Output:668*/ 分块的大部分题目并不像这样简单，例如下面的动态区间第 $K$ 小数例题. 给定一个由 $N$ 个数组成的序列 ${A_1,A_2,…,A_N}$每次可以将 $A_k$ 的值改为 $t$ ，或者提问序列中 ${A_l,..,A_r}$ 中第 $k$ 小的数的值. 对于这道题，我们需要使用另一个数组 $B$ 用来将每个块内的元素排序，需要查询时先使用二分答案，再在 check() 内对于整块的统计答案直接使用排序的数组进行二分，正所谓一个分块套二分再套二分，细节很多，详见下码. 123456789101112131415161718192021222324252627282930313233343536373839404142void modify(int k, int t) { // 单点修改，需要排序 int F = (k-1)/s+1; a[k] = t; b[F].clear(); for (int i = (F-1)*s+1; i &lt;= F*s; i++) { b[F].push_back(a[i]); } sort(b[F].begin(), b[F].end());}int check(int x, int y, int f) { // 统计信息 int i = (x-1)/s+1; int j = (y-1)/s+1; int ans = 0; if (i == j) { for (int k = x; k &lt;= y; k++) { if (a[k] &lt; f) ans++; } } else { for (int k = x; k &lt;= i*s; k++) { if (a[k] &lt; f) ans++; } for (int k = (j-1)*s+1; k &lt;= y; k++) { if (a[k] &lt; f) ans++; } for (int k = i+1; k &lt; j; k++) { ans += lower_bound(b[k].begin(), b[k].end(), f) -b[k].begin(); // 直接二分统计整块内的答案 } } return ans;}int query(int x, int y, int k) { // 二分答案 int l = 0, r = 50005, mid; while (l+1 &lt; r) { mid = (l+r)&gt;&gt;1; if (check(x, y, mid) &gt;= k) r = mid; else l = mid; } return l;} 除此之外，还有要同时开两个 lazy 的题目——数列分块入门7，关键在于处理两个运算法则之间的优先级. 数列分块入门5——在根号开到一定程度时块内的元素会全部变为 $1$，这时可以不用暴力统计，直接计算块长. 另外，还有一类分块题，算是属于半个块状数组(或者说块状链表). 众所周知，数组访问时间复杂度 $O(1)$ ，修改 $O(n)$ ，而链表访问 $O(n)$ ，修改 $O(1)$ . 而块状链表，就是两者的结合体，它查询 $O(\\sqrt n)$ ，修改 $O(\\sqrt n)$ ，两者时间复杂度相差不大，是个折中方案，具体长什么样见下图. 那我们应该如何维护来保证它们的时间复杂度呢？很简单，我们只需要在一个块的大小大于一定的值后暴力拆分成两块接在原块后面（什么细胞的无丝分裂，具体来说，我们要在一块的大小大于 $2\\sqrt N$ 时分裂(注意：此处的 $N$ 指的是所有元素，包括了后面新增的元素，也就是说每次添加元素时要重新计算阈值长度).理清思路后，代码实现很简单了(见下，例题). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int cnt; // 总块数，用于给新块编号int nc; // 元素总数typedef pair&lt;int, int&gt; pii; // 不会吧不会吧，都3202年了不会还有人不会用typedef吧pii locate(int x) { // 定位元素 int i = 1; while (x &gt; block[i].siz) { x -= block[i].siz; i = block[i].to; } return {i, x};}void split(int x, int y) { cnt++; for (int i = y; i &lt;= block[x].siz; i++) { block[cnt].a[++block[cnt].siz] = block[x].a[i]; block[x].a[i] = 0; } block[cnt].to = block[x].to; block[x].to = cnt;}// 临时定义一下（不要问我为什么不开变量#define x p.first#define y p.secondvoid insert(int t, int v) { pii p = locate(t); // 暴力插入 for (int i = block[x].siz; i &gt;= y; i--) { block[x].a[i+1] = block[x].a[i]; } block[x].siz++; block[x].a[y] = v; nc++; s = sqrt(nc); if (block[x].siz &gt;= 2*s) { split(x, block[x].siz/2+1); block[x].siz = block[x].siz/2; }}#undef x#undef yint query(int x) { // 极简的查询的函数 pii p = locate(x); return block[p.first].a[p.second];} 除了一般的分块题和块状链表外，分块还有一个重要作用——莫队，它可以解决一部分的区间查询题目(尤其是查询某种区间有几种值的). 先说本质，本质并不是分块，而是双指针.莫队在运行时会用到两个数组，一个是原来的数组，另一个是 cnt 数组，cnt 数组是用来记录每个数出现的次数(在某些时候可能需要配合离散化食用).下面是算法基本的运行过程. 首先我们有两个指针 i 和 j ，先不考虑为什么他们在这个位置上，现在我们要把他们移到既定位置.我们有一种很简单的思路，先把左( i )移到既定位置的左端点，再把右( j )移到既定位置的右端点上.而在这个期间，我们可以顺便统计 cnt 数组，并且维护 tot 变量(统计种类，具体来讲是在 cnt 某个值从0到1或是从1到0的过程中修正).于是我们就有了一个基本的模型了，就是不断通过移动双指针来处理每个询问，但是很明显，这样移来移去，i 最多会移动 $MN$ 次( $M$ 是询问次数，$N$ 是数组长度)，j 也同理，这样的时间复杂度是不行的.而莫队算法就是在此处做了优化. 莫队首先会把询问离线，并把数组的点进行分块，而排序询问的第一关键字是每个询问左端点所在块的编号，而第二关键字是右端点.具体实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, s;int a[50050], cnt[1000010];int ans[200020], tot = 0; // ans是将答案还原的数组struct node { int l, r, id;} q[200020];bool cmp(node a, node b) { if ((a.l-1)/s+1 == (b.l-1)/s+1) return a.r &lt; b.r; // 排序 return a.l &lt; b.l;}void add(int p) { if (++cnt[a[p]] == 1) tot++; // 对应左端点左移与右端点右移}void del(int p) { if (--cnt[a[p]] == 0) tot--; // 对应左端点右移与右端点左移}signed main() { cin &gt;&gt; n; s = sqrt(n); for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; } cin &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; q[i].l &gt;&gt; q[i].r; q[i].id = i; } sort(q+1, q+m+1, cmp); // 处理询问 int l = 0, r = 0; for (int i = 1; i &lt;= m; i++) { while (r &lt; q[i].r) add(++r); while (r &gt; q[i].r) del(r--); while (l &lt; q[i].l) del(l++); while (l &gt; q[i].l) add(--l); ans[q[i].id] = tot; } for (int i = 1; i &lt;= m; i++) { cout &lt;&lt; ans[i] &lt;&lt; endl; } return 0;} 除此之外，莫队还有一种带修改版本. 不是说了将询问离线了吗，离线处理时怎么修改啊. 还是可以修改的，现在带修改功能得将修改的点还原到询问前的状态. 现在时间也得移来移去了. 嗯？时间移来移去？像 i 和 j 那样？ 那这就好实现了啊.新增一维来处理时间. 具体怎么讲？ 记录一下每次修改前后的状态，每次将时间移动时便一步步更换状态，直到回溯到指定时间，同时 cmp 函数也要改一下. 于是，我们就有了这个代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;// 回避关键词检测的打包函数#define pack1 {x, y, ccnt, qcnt}#define pack2 {x, y}using namespace std;int l, r;int n, m, s, tcnt;int a[133344], cnt[1000010];int ans[133344], tot;int chunk[133344];struct node{ // 记录询问 int l, r, t, i;}q[133344];int qcnt;bool cmp(node a, node b) { // 新的排序函数 if (chunk[a.l] == chunk[b.l] &amp;&amp; chunk[a.r] == chunk[b.r]) return a.t &lt; b.t; if (chunk[a.l] == chunk[b.l]) return a.r &lt; b.r; return a.l &lt; b.l;}struct cg{ // 记录修改 int i, v;}c[133344];int ccnt;void add(int p) { tot += !cnt[p]++; // 用于l与r的修改，意义同上}void del(int p) { tot -= !--cnt[p]; // 同上}void timem(int i, int p) { if (q[i].l &lt;= c[p].i &amp;&amp; c[p].i &lt;= q[i].r) { // 时间更改器（雾 del(a[c[p].i]); add(c[p].v); } swap(a[c[p].i], c[p].v); // 因为有去必有回，所以下一次使用这个位置一定是把它更改回来}int main() { cin &gt;&gt; n &gt;&gt; m; s = pow(n*1.0, 2.0/3.0); // 适用于莫队的特殊分块大小 for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; chunk[i] = (i-1)/s+1; // 记录块号（也可以不记） } for (int i = 1; i &lt;= m; i++) { char op; int x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if (op == 'Q') { q[++qcnt] = pack1; } else { c[++ccnt] = pack2; } } sort(q+1, q+qcnt+1, cmp); int l, r, t; l = r = t = 0; for (int i = 1; i &lt;= qcnt; i++) { // 将三个维度移至指定位置 while (l &lt; q[i].l) del(a[l++]); while (l &gt; q[i].l) add(a[--l]); while (r &lt; q[i].r) add(a[++r]); while (r &gt; q[i].r) del(a[r--]); while (t &lt; q[i].t) timem(i, ++t); while (t &gt; q[i].t) timem(i, t--); ans[q[i].i] = tot; // 记录答案 } for (int i = 1; i &lt;= qcnt; i++) { cout &lt;&lt; ans[i] &lt;&lt; endl; } return 0;} Part 分块思想 End 矩阵部分咕一会… update: 2023/12/12 还没写。。。 update: 2024/01/01 还没写。。。","link":"/2023/12/28/%E5%88%86%E5%9D%97%E4%B8%8E%E7%9F%A9%E9%98%B5/"},{"title":"最短路基础","text":"前置知识：图论基础 Floyd算法用于求解任意两点的最短路。","link":"/2024/01/01/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%9F%BA%E7%A1%80/"},{"title":"最短路技巧","text":"前置知识：图论基础，最短路基础 1. Super Root 超级源点、加点、加边特征 需要添加边，但是暴力加边时间or空间复杂度不可取； 加边是针对某一类点加边； 答案最终会汇集到一个点上，一些网络流的题需要建立超级源点和超级汇点。 注意点 加边时考虑边权设计； 如果要对超级源点加双向边，要考虑周全一些不合法的情况，例如会不会无边权超级传送； 加点要算好空间，算好下标。 例题 给定一棵树，$1$ 为根节点，对于树上每条边 $(u, v)$ 都具有一个权值 $w$ 。但是，如果两个节点的高度差为 $k$ ，则可以通过 $p$ 的权值直接到达，求在这棵树上从 $s$ 到 $t$ 的最短路径长度。多组测试数据。$1 \\le T \\le 5$$2 \\le n \\le 10^6$$1 \\le u_i,v_i,s,t \\le n, u_i \\neq v_i, s \\neq t$$1 \\le w_i,k \\le 10^6$$0 \\le p \\le 10^6$ 我们发现这道题需要加边跑最短路，然而，$\\text{Dijkstra}$ 带上加边会跑到 $O((n+m+n^3)\\log (m+n^3)+n^3)$ ，这里极限数据的情况是整棵树有 $\\sqrt n$ 层，每层有 $\\sqrt n$ 个点，且 $k = 1$ 。即使我们不真正连边，仍然还有 $O((n+m+n^3)\\log (m+n^3))$ 的时间复杂度。死得透透的。 因此我们考虑对每一层建立一个超级源点，边权为 $0$ ，再对上下 $k$ 层的超级源点连边，因为这个点既可以上又可以下，所以要连双向边。然鹅，这个方案有一个巨大的问题。 如果我们连双向边，那么最短路会借助超级源点在同一层实现 $0$ 权值跳转，很明显，这是不合法的。于是我们考虑每层加两个超级源点，一个用于向外走，一个向内走，问题就解决了，时间复杂度 $O((5n+m)\\log (2n+m))$ 。 给出一个图，每次只能连续走两条边，其权值为两条边权值的和的平方，求以 $1$ 为源点时分别到 $1\\sim n$ 的最短路。$2 \\leqslant n \\leqslant 10^5,1 \\leqslant m\\leqslant min(\\frac{n(n-1)}{2},2*10^5)$$1\\leqslant v_i,u_i \\leqslant n,1 \\leqslant w_i \\leqslant50,u_i\\neq v_i$ 同时处理两条边是有些困难的。考虑往图里增加信息。我们发现边权十分小，只有 $50$ 。于是我们想到建分层图，入边 $(u,v,w)$ 即建一条边从第 $w$ 层图 $v$ 点到原图 $v$ 点，出边 $(u,v,w)$ 就是建一条边从原图 $v$ 点到第 $w$ 层图 $v$ 点。这样做正确性显然。 2. 最短路计数这里要提两个概念 附录SPFA玄学优化据某位不知名人士所言，SPFA的时间复杂度可以用 $O(m+n\\log n)$ 来拟合，而Dijkstra的时间复杂度为 $O(m\\log n)$ 。这意味着如果题目不卡SPFA，则SPFA跑得比Dijkstra还要快。如果卡SPFA，还可以通过SLF、mcfx等优化方法来使SPFA更快。甚至专门卡SPFA的标准版单源最短路径的次优解（$\\text{80ms}$）就是使用了SLF-swap优化过的。","link":"/2024/01/01/%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%8A%80%E5%B7%A7/"},{"title":"图论基础","text":"存图邻接矩阵实现： 12345678int g[N][N];g[u][v] = w;for (int v = 1; v &lt;= N; v++) { if (!g[u][v]) continue; // ...} 空间复杂度：$O(n^2)$ 优点 配合Floyd算法，效果嘎嘎好 支持随机访问，即直接查询某条边是否存在 代码好写 缺点 空间复杂度太高，是个硬伤 邻接表实现： 12345678vector&lt;pair&lt;int, int&gt;&gt; g[N];g[u].push_back({v, w});for (pair&lt;int,int&gt; i : g[u]) { int v = i.first, w = i.second; // ...} 空间复杂度：$O(m)$ 优点 空间复杂度小 同一个点空间连续，有效降低Memory Cache带来的时间花销 写循环遍历 $u$ 边时可以少写点代码：for (pair&lt;int,int&gt; i : g[u]) 缺点 由于 vector ，空间复杂度要翻个倍，在卡空间的题目中它不是好选择 莫名其妙TLE（STL造成的） 链式前向星实现： 1234567891011121314struct node{ int to, nxt, w;}g[M];int head[N], cnt;void add(int u, int v, int w) { g[++cnt] = {v, head[u], w}; head[u] = cnt;}for (int i = head[u]; i; i = g[i].nxt) { int v = g[i].to, w = g[i].w; // ...} 空间复杂度：$O(m)$ 优点 空间复杂度真的小，没有 vector 的两倍空间限制 缺点 Memory Cache耗时极高，尤其是完全图","link":"/2023/12/28/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/"},{"title":"组合数与乘法逆元","text":"Part 1. 组合数众所周知，组合数有两种求法。 杨辉三角求法：$\\dbinom{i}{j}=\\dbinom{i-1}{j}+\\dbinom{i-1}{j-1}$ 定义法：$\\dbinom{i}{j}=\\Large\\frac{n!}{m!(n-m)!}$ 其中，杨辉三角的空间占用很大，所以除非数据量较小（如：$N\\leqslant 10^{4}$）的情况，我们不会使用这种求法，但是这种求法可以实现 $O(1)$ 查询，因此它也适用于需要大量查询的题目。而定义法适用于不需要大量查询（至少没有杨辉三角的情况多）的题目，但是因为有阶乘的存在，使得实现 $O(1)$ 还需要一点点数学上的优化，并且，其适用的数据范围（$N\\leqslant 10^5$）一般都需要 $mod$ 一个极大数（阶乘不 $mod$ 留着爆 $long;long$ 吗），然而我们都知道，同余的性质不适用于除法，这导致我们处于一个进退两难的地步。古语有云：$To;modulo;or;not;to;do,;it’s;a;question.$这时候，我们就需要乘法逆元来帮忙了。 Part 2. 乘法逆元按照惯例，先说定义：如果一个线性同余方程 $ax\\equiv 1(\\mathrm{mod};b)$ ，则称 $x$ 为 $a;\\mathrm{mod};b$ 的逆元，记为 $a^{-1}$ 。我们可以把它理解成倒数，一种在模 $p$ 意义下的倒数。因此，我们可以知道一个数逆元的逆元就是这个数本身。逆元的求法有两种： Extend-GCD 拓展欧几里得法就是直接解上述定义中的方程，没什么好说的。 123456789void exgcd(int a, int b, int &amp;x, int &amp;y) { if (b == 0) { x = 1, y = 0; return ; } exgcd(b, a%b, x, y); y -= a/b*x; return ;} 快速幂法$\\huge 使用这玩意的前提是;b;为质数！$ 证明： $\\because ax\\equiv 1(\\mathrm{mod};b)$由费马小定理: $a^{p-1}\\equiv1(\\mathrm{mod};b)$得 $ax\\equiv a^{p-1}(\\mathrm{mod};b)$$\\therefore x\\equiv a^{p-2}(\\mathrm{mod};b)$ 所以我们可以直接写一个快速幂板板！ 12345678910int power(int a, int b) { b -= 2; int ans = 1; while (b) { if (b&amp;1) ans = ans*a%p; a = a*a%p; b &gt;&gt;= 1; } return ans;} 除此之外，我们还可以使用线性递推求一大串数的逆元（但是我不会推）。 $i^{-1}\\equiv\\begin{cases}1&amp;\\mathrm{if};i=1\\-\\left\\lfloor\\dfrac{p}{i}\\right\\rfloor (p;\\mathrm{mod};i)^{-1}&amp;\\mathrm{otherwise.}\\end{cases};(\\mathrm{mod};p)$ 那么，归根结底，我们到底如何使用乘法逆元加速定义法的组合数呢？ Part 3. 乘法逆元优化组合数我们不能使用定义法求带模组合数是因为除法不具备同余的性质，但是，我们可以用逆元将除法转化为乘法，进而求出组合数。那么，原来的定义法公式可以转化为 $\\dbinom{i}{j}=\\large n!\\times inv[m] \\times inv[n-m]$（还是说可以把逆元理解为倒数）首先，$n!$ 是可以预处理出来的，而 $inv[i]$ 使用上面说的两种方式很明显会 $TLE$ (但事实上并不会) ，剩下的只有一条路了——递推。首先，我们还是可以使用上面说到的递推公式，但是对于阶乘，我们还有另一个递推公式：$$inv[i!]=inv[(i+1)!]\\times (i+1)$$怎么理解呢？还记得我们说过，逆元就是一种倒数吗？借此，有如下公式：$$ \\frac{1}{i!}=\\frac{1}{(i+1)!}\\times (i+1) $$答案已经呼之欲出了！","link":"/2023/12/28/%E7%BB%84%E5%90%88%E6%95%B0%E4%B8%8E%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"},{"title":"背包问题","text":"Ⅰ. 基础模型A. 01背包即每个物品要么选，要么不选。我们可以设状态 $f_{i,j}$ 表示考虑前 $i$ 个物品总体积 $\\leq j$ 的最大价值，于是状态转移如下： $$f_{i,j}=\\max(f_{i-1,j},f_{i-1,j-w_i}+v_i)$$ 前一个表示不选第 $i$ 个物品的情况，后一个表示选第 $i$ 个物品的情况。 初始化：$f_{i,j}=0$ 。 考虑怎么统计方案数。状态定义一样，但是表示的是方案数，于是又有转移方程如下： $$f_{i,j}=f_{i-1,j}+f_{i-1,j-w_i}$$ 初始化：$f_{i,0}=f_{0,j}=1$ 。 考虑优化空间，我们发现，每次转移只会用到上一维的状态，于是就可以把DP数组压成一维。代码如下： 12345for (int i = 1; i &lt;= n; i++) { for (int j = m; j &gt;= w[i]; j--) { f[j] = max(f[j], f[j-w[i]]+v[i]); }} B. 完全背包就是在01背包的基础上每个物品可以选任意多个。状态设计同01背包，转移如下： $$f_{i,j}=\\max(f_{i-1,j},f_{i,j-w_i}+v_i)$$ 区别在哪里呢？完全背包可以从当前的 $i$ 的状态转移过来，因为一个物品可以一选再选。 初始化、变形成方案数统计和压空间和上面的01背包大同小异，不过多赘述。贴个优化空间代码： 12345for (int i = 1; i &lt;= n; i++) { for (int j = w[i]; j &lt;= m; j++) { f[j] = max(f[j], f[j-w[i]]+v[i]); }} C. 多重背包","link":"/2023/12/28/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"title":"题目思路存储","text":"奇怪的最短路问题原题：HDU6166/P5304/LOJ#3087 法一维护最短路和次短路以及它们的来源点。具体有待补充。 法二一种套路：多源多汇最短路。 多源多汇怎么做？ 建一个超级源点和超级汇点，但是这样从源点出来就可以0权到汇点。 解决方案： 随机划分： $p=\\frac{1}{4}$，T次成功概率：$1-(1-p)^T$，虽然 $20$ 次随机成功概率为 $99.68\\%$，但毕竟是概率，不够靠谱并且基于RP。 二进制分组： 按照二进制的一个位置上的 $01$ 值来划分谁是源点谁是汇点，由数据范围知最多 $17$ 次划分，每次需要跑两遍。有点卡时限但能过。 指针分析复习指针？ 题目中给的关系实际上是一些边的关系，但是这些边有些限制。 某些边有激活条件，例如一个指针得先指向某个地址之后才能访问。 小模拟，将题目操作转化为代码。 Bellman-ford 思想：不断松弛，在过程中实现 $4$ 种操作并同时维护。 实现思路1：set 维护每个点能到哪些点 实现思路2：状态压缩 关于优化： 基于RP：减少松弛轮数 基于卡常：快读 基于随机化：shuffle+clock() 卡时间 老算法焕发新生。 果国的奇妙旅行带决策的期望。 #define 卡 票 定义 $E(u)$ 表示 $u$ 到终点的期望。 此题目要求在最优策略下到终点的期望抽卡次数，可以发现所谓最优策略就是贪心：如果我抽到的卡走过去的期望 $E(v)$ 较 $E(u)$ 而言减小了，即 $E(u) &gt; E(v)$，那么我们就可以走到 $v$，定义这就是一次成功的决策。 也就是说，如果我抽到的卡能使我的期望减小，那么就走，否则扔掉重来。于是我们的转移就可以分为两种情况：一种是 $v$ 向 $u$ 转移；另一种是不转移。 我们又发现，从结果来看，如果 $u$ 走到 $v$ 这个决策是成功的，那么 $v$ 走到 $u$ 的决策一定是不成功的，因为 $E(u) &gt; E(v)$，就一定 $E(u) &gt; E(v)$ （满篇废话，然而这种显著的废话往往是最难发现并利用的）。 综上，我们就认为 $u$ 的转移是有方向的。 根据以上的情况讨论，不难得到 $E(u)$ 转移如下： $$E(u)=\\sum_{v\\in e(u)}^{E(v) &lt; E(u)}{\\frac{E(v)}{deg(u)}}+\\sum_{v\\in e(u)}^{E(v)\\geq E(u)}{\\frac{E(u)}{deg(u)}}+1$$ 设 $x=\\sum[v\\in e(u) \\And E(v) \\geq E(u)],;d=deg(u)$ 化简过程： $$E(u)=\\frac{1}{d}(\\sum_{v\\in e(u)}^{E(v) &lt; E(u)}{E(v)}+xE(u))+1$$ $$dE(u)=\\sum_{v\\in e(u)}^{E(v) &lt; E(u)}{E(v)}+xE(u)+d$$ $$(d-x)E(u)=\\sum_{v\\in e(u)}^{E(v) &lt; E(u)}{E(v)}+d$$ 得到： $$E(u)=\\sum_{v\\in e(u)}^{E(v) &lt; E(u)}{\\frac{E(v)}{d-x}}+\\frac{d}{d-x}$$ 十分抽象的一点是：我确定边的方向需要 $u$ 和 $v$ 的期望来进行大小比较，然而期望又需要边的方向来更新。问题就是如何打破这个循环。 数学上的推导不太可能了，考虑从更新顺序入手。 目前这里的方法是填表法，考虑使用刷表法，即对于每个 $u$ 去更新它的 $v$。考虑使用Dijkstra算法。而且不难发现，$E(u)$ 的值随着更新不断减小（分母变大）。 像这种破逻辑的环很难解决，切入口不好找，因此这里直接放结论。 一开始设置 $E(u)=+\\infty$ ，然后让 $E(v)$ 从小到大更新 $E(u)$ 。 （为什么这样可行我也不会证。可能需要数学归纳法。） 最后，因为 $E(u)$ 的定义是 $u$ 到终点的期望，因此搜索时应该从终点开始搜。（思考：从起点搜结果会受影响吗？） 推完了。 至于怎么实现还得是Dijkstra。 事实上，指针分析 和 果国的奇妙旅行 都不是最短路的题目，但是借用了最短路算法的思想，不愧为《最新颖的一集》。","link":"/2023/12/30/%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E5%AD%98%E5%82%A8/"},{"title":"欧拉反演","text":"果果要求掌握的东西当然是要掌握的咯。 最终形式$$\\Large{n=\\sum_{d|n}^{}}{\\varphi(d)}$$ 证明$$\\large\\because n=\\sum_{d|n}\\sum_{j=1}^{n}{[\\gcd(j,n)=d]}$$ 解释一下，首先，这里的 $\\gcd(j,n)$ 一定是只有一个值，不可能说有两个不同的值来自同一个 $\\gcd(j,n)$ ；其次，为什么这一坨东西等于 $n$ 呢，因为其一说的每个 $\\gcd$ 都有唯一确定的值，因此我们只需要枚举 $\\gcd$ 的每种可能并枚举所有 $n$ 以内的正整数就必然有且仅有一种可能的 $d$ 满足每组 $\\gcd(j,n)=d$ 。 换句话说，因为一个 $\\gcd(j,n)$ 只对应唯一一个 $d$ ，这里我们把所有可能的 $\\gcd$ 的值和所有的 j 都枚举了自然其值也就等于 $n$ 了（主要就是说明一个不重也不漏）。 $$\\large\\therefore \\ n=\\sum_{d|n}\\sum_{j=1}^{\\frac{n}{d}}{[\\gcd(j,\\frac{n}{d})=1]}$$ 这里没什么好说的，目的是把 $\\gcd$ 的值化为 $1$ 后能转化成欧拉函数的形式。 $$\\large\\therefore n=\\sum_{d|n}{\\varphi(\\frac{n}{d})}$$ $$\\large\\therefore n=\\sum_{d|n}{\\varphi(d)}$$ 这里是因为每个 $\\frac{n}{d}$ 和 $d$ 是对应的，所以能如此转化。 例题 多组数据，每组数据给出一个数 $n$ ，求 $\\sum_{i=1}^{n}{\\gcd(i,n)}$ 。 利用欧拉反演，改变题目公式如下： $$\\sum_{i=1}^{n}{\\sum_{d|\\gcd(i,n)}{\\varphi(d)}}$$ 拆开 $\\gcd$ 得： $$\\sum_{i=1}^{n}{\\sum_{d|i,d|n}{\\varphi(d)}}$$ 改变循环顺序得： $$\\sum_{d|n}\\varphi(d)\\sum_{i=1}^{n}[d|i]$$ 化简得： $$\\sum_{d|n}\\varphi(d)\\frac{n}{d}$$ 关于推导式子就没了。这时只需将 $\\text{phi}$ 预处理，每次询问 $\\sqrt{n}$ 复杂度。 CF1900D Small GCD 先排序，可得以下原公式： $$\\sum_{i=1}^{n}\\sum_{j=1}^{i-1}\\gcd(a_i,a_j)(n-i)$$ 带入欧拉反演如下： $$\\sum_{i=1}^{n}\\sum_{j=1}^{i-1}(\\sum_{d|\\gcd(a_i,a_j)}{\\varphi(d)})(n-i)$$ 化简： $$\\sum_{i=1}^{n}(n-i)\\sum_{j=1}^{i-1}\\sum_{d|a_i,d|a_j}{\\varphi(d)}$$ $$\\sum_{i=1}^{n}(n-i)\\sum_{d|a_i}\\varphi(d)\\sum_{j=1}^{i-1}[d|a_j]$$ $$\\sum_{i=1}^{n}(n-i)\\sum_{d|a_i}\\varphi(d)\\cdot cnt_{d}$$ 其中我们可以边枚举 $i$ 边处理 $cnt_d$ ，并预处理 $\\varphi(x)$ 。因此总时间复杂度为 $O(M+TN\\sqrt{M})$ ，$M$ 表示 $a_i$ 的值域，还会有一些小常数，会有点卡常。 果果要求掌握的东西当然是要掌握的咯。 最终形式$$\\Large{n=\\sum_{d|n}^{}}{\\varphi(d)}$$ 证明 $$\\large\\because n=\\sum_{d|n}\\sum_{j=1}^{n}{[\\gcd(j,n)=d]}$$ 解释一下，首先，这里的 $\\gcd(j,n)$ 一定是只有一个值，不可能说有两个不同的值来自同一个 $\\gcd(j,n)$ ；其次，为什么这一坨东西等于 $n$ 呢，因为其一说的每个 $\\gcd$ 都有唯一确定的值，因此我们只需要枚举 $\\gcd$ 的每种可能并枚举所有 $n$ 以内的正整数就必然有且仅有一种可能的 $d$ 满足每组 $\\gcd(j,n)=d$ 。 换句话说，因为一个 $\\gcd(j,n)$ 只对应唯一一个 $d$ ，这里我们把所有可能的 $\\gcd$ 的值和所有的 $j$ 都枚举了自然其值也就等于 $n$ 了（主要就是说明一个不重也不漏）。 $$\\large\\therefore \\ n=\\sum_{d|n}\\sum_{j=1}^{\\frac{n}{d}}{[\\gcd(j,\\frac{n}{d})=1]}$$ 这里没什么好说的，目的是把 $\\gcd$ 的值化为 $1$ 后能转化成欧拉函数的形式。 $$\\large\\therefore n=\\sum_{d|n}{\\varphi(\\frac{n}{d})}$$ $$\\large\\therefore n=\\sum_{d|n}{\\varphi(d)}$$ 这里是因为每个 $\\frac{n}{d}$ 和 $d$ 是对应的，所以能如此转化。 例题 多组数据，每组数据给出一个数 $n$ ，求 $\\sum_{i=1}^{n}{\\gcd(i,n)}$ 。 利用欧拉反演，改变题目公式如下： $$\\sum_{i=1}^{n}{\\sum_{d|\\gcd(i,n)}{\\varphi(d)}}$$ 拆开 $\\gcd$ 得： $$\\sum_{i=1}^{n}{\\sum_{d|i,d|n}{\\varphi(d)}}$$ 改变循环顺序得： $$\\sum_{d|n}\\varphi(d)\\sum_{i=1}^{n}[d|i]$$ 化简得： $$\\sum_{d|n}\\varphi(d)\\frac{n}{d}$$ 关于推导式子就没了。这时只需将 $\\text{phi}$ 预处理，每次询问 $\\sqrt{n}$ 复杂度。 CF1900D Small GCD 先排序，可得以下原公式： $$\\sum_{i=1}^{n}\\sum_{j=1}^{i-1}\\gcd(a_i,a_j)(n-i)$$ 带入欧拉反演如下： $$\\sum_{i=1}^{n}\\sum_{j=1}^{i-1}(\\sum_{d|\\gcd(a_i,a_j)}{\\varphi(d)})(n-i)$$ 化简： $$\\sum_{i=1}^{n}(n-i)\\sum_{j=1}^{i-1}\\sum_{d|a_i,d|a_j}{\\varphi(d)}$$ $$\\sum_{i=1}^{n}(n-i)\\sum_{d|a_i}\\varphi(d)\\sum_{j=1}^{i-1}[d|a_j]$$ $$\\sum_{i=1}^{n}(n-i)\\sum_{d|a_i}\\varphi(d)\\cdot cnt_{d}$$ 其中我们可以边枚举 $i$ 边处理 $cnt_d$ ，并预处理 $\\varphi(x)$ 。因此总时间复杂度为 $O(M+TN\\sqrt{M})$ ，$M$ 表示 $a_i$ 的值域，还会有一些小常数，会有点卡常。","link":"/2023/12/28/%E6%AC%A7%E6%8B%89%E5%8F%8D%E6%BC%94/"}],"tags":[{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"二分图","slug":"二分图","link":"/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"连通块","slug":"连通块","link":"/tags/%E8%BF%9E%E9%80%9A%E5%9D%97/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"排列组合","slug":"排列组合","link":"/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"},{"name":"乘法逆元","slug":"乘法逆元","link":"/tags/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"},{"name":"背包问题","slug":"背包问题","link":"/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"存储","slug":"存储","link":"/tags/%E5%AD%98%E5%82%A8/"},{"name":"欧拉反演","slug":"欧拉反演","link":"/tags/%E6%AC%A7%E6%8B%89%E5%8F%8D%E6%BC%94/"}],"categories":[{"name":"学习总结","slug":"学习总结","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"图论","slug":"学习总结/图论","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%9B%BE%E8%AE%BA/"},{"name":"动态规划","slug":"学习总结/动态规划","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数学","slug":"学习总结/数学","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6/"},{"name":"思想","slug":"学习总结/思想","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E6%80%9D%E6%83%B3/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"最短路","slug":"学习总结/图论/最短路","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"pages":[]}