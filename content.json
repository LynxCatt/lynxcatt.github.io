{"posts":[{"title":"CSP-J&#x2F;S2 游记","text":"$\\text{I don’t know this person is 2B or not 2B.}$ Day $-1$回想起了初赛S组的难度以及一个卡分数线过的我。我感觉第二天的考试要炸，思前想后感觉这种时候可能也做不了什么知识性的事了，于是就把文件快读的模板背了一下（虽然不知道明天是否有用）。无论如何，这天奇迹般地睡了个好觉。 Day $0$Backroom Day $1\\frac{1}{3}$$8:30$上J组考场，VS Code能正常用！J组的AB两道题都比较简单——新时代的大水题！其中 $\\text{T1}$ ，一开始看的时候没什么思路，盯着电脑想了十几分钟，还是决定从部分分拿起，打完第一问后一分多钟第二问就出来了，$\\text{T1}$ 就拿下了。打完后测过大样例觉得有点后怕，还是把文件快读加上了。然后开 $\\text{T2}$ ，看到标题一瞬间想到之前做过的一道题（尽管题面并不一样），看完题面后想到了贪心并且觉得应该一段一段的考虑，略加调试，就通过了样例。之后有一段时间对着大样例调试，发现之前没用完的油要接着考虑，再次修改代码，结束 $\\text{T2}$。 $\\text{T1}+\\text{T2}=70\\text{min}$ $9:(3\\sqrt{5})^2$发现 $\\text{T3}$ 是一道大模拟，然后飞快看了眼 $\\text{T4}$ 并断定不会，于是就老老实实打 $\\text{T3}$ 了。$\\text{T3}$ 是我唯一一道打了表的题，这是我在正式考试中头一次使用打素数表这种不光彩的方法，打起来感觉比之前我所写过的大模拟舒服得多，大样例也给得毫不吝啬，帮助我发现了许多bug，例如最大的解为 $0$ 的情况。总之，最后通过了大样例，$\\text{T3}$ 宣告结束了！ 这里是考后视角，虽然目前没有发现任何bug，但是小*灵和*斗都只拿到了 $80$ 分，$\\text{I don’t know Y}$ ，唯有洛谷给出了 $100$ 分的佳绩，希望得到洛谷的hack数据，希望CCF的样例和洛谷一样水！！！ 然后就去打 $\\text{T4}$ ，想了想有了正解的思路，最后打了个 $\\text{dfs}$ ，思路是在深搜过程中记录要求最严苛的点，最后加到 $ans$ 里面一起统计答案去。 在洛谷上取得了 $35$ 分的好成绩，在小*灵上取得了 $15$ 分的成绩，再次衷心祝愿CCF数据出水点！然而，考后我把深搜改成了广搜，并且把记录内容从最严苛的点变成了最晚出发时间，然后 $35\\rightarrow 90$ （真的想吐）。最关键的是，但凡我是一个正常人，我看完这道题后就应该记录最直接的数据二分这种垃圾玩意！虽然正解是二分+同余最短路，但是以我对CCF的最后一丝幻想，我觉得CCF不会在普及组出这么恶心的东西，而且，二分起始时间的思路似乎已经被同机房的大佬hack了，因此我厚颜无耻地认为“我的思路是正解”。 Day $1\\frac{7}{12}$$14:00$打提高组，然后寄了。 除了 $\\text{T1}$ 以外其他题都大寄特寄！ 整个过程没什么好说的，$\\text{T1}$ 打完（$1\\text{hour}$）之后的所有时间都去打 $\\text{T2}$ 去了，然后 $\\text{T2}$ 只打了个区间DP，比赛就结束了。 考后震惊地发现 $\\text{T3}$ 打太急了甚至没有编译，导致编译错误，但是我会自我安慰——即使没有CE也会爆零。我谢罪！","link":"/2023/10/25/CSP-JS2%E6%B8%B8%E8%AE%B0/"},{"title":"2023解题报告","text":"十一月开这个坑已经是月底了，记录一下几个题目。 Atcoder Beginning Contest 330 E - Mex and Update我认为这是一道不错的性质题。 当时在考场上看出了这道题有性质，但是并没有推导出性质。性质主要就是对于一个长度为 $n$ 的数组，其 $\\text{mex}$ 一定是在 $0$ 到 $n$ 内的，至于怎么证明……简单抽屉原理。 然后就是怎么维护这个 $\\text{mex}$ ，可以用 $\\text{set}$ 记录没有在数组中的 $0$ 到 $n$ 的数的集合，因为 $set$ 可以自动排序，所以查询就是 $\\text{set.begin}$ ，维护时还需要维护每个数在数列中的出现次数，不然会误加元素进 $\\text{set}$。没了。 Codeforces 1900 E - Transitive Graph最考码力の一题。 首先还是有个性质（还没严格证明）：如果一堆点在原图SCC内，那么最后它们一定能化成一个完全图——这个SCC内每个点，都能直接互相到达。 因此，我们可以先缩点，然后对于缩出来的点建DAG跑拓扑排序，答案也可以在拓扑过程中更新。That’s all.","link":"/2023/11/29/2023%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"title":"1005考试总结","text":"1005比赛总结时间线 Time Line 08:00 开始考试 08:00 开 $A$ 09:45 结束 $A$，开 $B$ 10:10 结束 $B$，开 $C$ 11:00 开 $\\text{Excel}$ ，跑 $C$ 大样例 11:45 结束 $C$，开 $D$ 12:00 结束考试 结果 Result $A;;40,pts.$ (低于预期) $B;;80,pts.$ (高于预期) $C;;35,pts.$ (低于预期) $D;;0;,pts.$ (不好评价) $Total;;155,pts.$ 从排名来看高于预期，从绝对得分来看符合预期。 总结 Summary首先，这次比赛最大的一个问题是时间的安排，$A$ 与 $C$ 题均耗费了一个小时以上的时间，导致 $B$ 与 $C$ 题只有很少的时间写。戏剧性的是，$B$ 只耗费了 $25\\text{min}$ 却是本场比赛中拿分最高的题。 其次则是思路上的问题，$A$ 题在赛时有正解的想法，但是因为没有仔细下去或是不敢往下想而放弃（那时已经 9:10 了，因此不敢拿剩下的时间去赌这道题）。$C$ 题也是如此，在提交代码后大约 $30\\text{s}$ 就找的了赛时没找到的 BUG。 最后就是码力上的问题，其实也是因为思路被禁锢了，$C$ 题明明有一种写起来+调起来都更舒服的方式，可惜没想到，导致耗费了大量时间在调试上。 这告诉我什么？ 及时止损，切换思路 提高码力，估准难度 仔细思考，加强深度 合理化时间分配 关于知识点的联系 暴力！暴力！暴力！！！不会也得打暴力！ 第一阶段总结第一阶段主要是关于动态规划的序列问题的，可以分为两种： 最长公共子序列（LCS） 最长上升子序列（LIS） 首先，LIS可以用来求LCS，其时间复杂度为 $O(n\\log n)$ 。 最长公共子序列又有几个经典问题： 求长度（模板） 求方案数：动态规划+转移计数 求方案：动态规划+转移倒推 求字典序最小方案：动态规划+统计字母出现位置 给定两个字符串求最短包含串的方案（数）：动态规划+双指针 而最长上升子序列的问题就多了去了，以下只列一些： 求长度（模板） 求字典序最小/大方案（动态规划+贪心递推） 求方案数（动态规划+计数+ $O(n\\log n)$ 树状数组或二分优化） 求本质不同的方案数（同上，加个去重） 求LCS（用一个序列“离散化”另一个序列） 判断一个数是否出现在LIS上（动态规划$O(n\\log n)$+统计位置：一定在序列上的数位置不变，不一定则位置可能变化） 构造指定长度的LISDL序列（不好说） 一阶段的问题主要都体现在1005的比赛中了，比赛中的问题就是要解决的问题。 关于最长上升子序列的 $O(n\\log n)$ 写法： 1. 二分空间复杂度 $O(n)$ 即数组长度空间。 这种方法本身不能求出具体方案，可以求出最长上升子序列的长度。 其原理简单来说就是对于每次新加一个元素，看它是否能接着当前这个序列下去，如果不能，则找到最小的一个大于（等于）它的元素并替换。 代码实现如下： 12345678memset(g, 0x3f, sizeof g);int ans = 0;for (int i = 1; i &lt;= n; i++) { int p = lower_bound(g+1, g+n+1, a[i]) - g; g[p] = a[i]; f[i] = p;}while (g[(++ans)+1] != inf) continue; （f 数组的定义和朴素转移一样，$f_i$ 记录以 $a_i$ 结尾的最长上升子序列） 2. 树状数组注意：本方法空间复杂度为 $O(k)$ （$k$ 是 $a_i$ 的取值范围） 所谓优化，要么在算法上优化，码量小，但难想；如果在数据结构上优化，码量大，但是基本不动脑子。 具体而言，我们做出如下分析： 优化什么？第二维 j 的转移。 怎么优化？树状数组，对值域开数组，每次转移拿当前的 $a_i$ 的值查询并更新树状数组。 如何证明正确性？感性理解，分析朴素转移中有哪些限制：①. $j&lt;i$；②. $a_j&lt;a_i$。①我们在循环更新的过程中从未往数组中加入 $i\\leq j$ 的元素，自然也不会从后面的状态转移过来；②因为我们是对值域开数组，因此在当前 $a_i$ 前面的一定是那些 $a_j&lt;a_i$ 的状态。 至此，所有问题均被解决，剩下的只是代码实现了（这里不贴代码了，待会连着统计方案数的题一起贴）。 注意树状数组只是优化哪些数能被转移以及加快转移过程，不是把 f 数组开到树状数组上！ 有了这些法宝，接下来就看例题啦！ 经典例题例一题目：给定字符串 $a$ 和 $b$ ，求最短的字符串 $c$ ，使得 $a$ 与 $b$ 均为 $c$ 的子序列。输出所有满足条件的 $c$ 中字典序最小的。","link":"/2023/12/28/1005%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/"},{"title":"0106考试总结","text":"标签：随机化根号分治 随机两个数作差，枚举这个数的因数作为可能的答案验证。","link":"/2024/01/06/0106%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/"},{"title":"Memory Cache","text":"Memory Cache视频介绍：影响运行时间常数的因素 5 —— Memory Cache CF博客：On Cache Friendliness","link":"/2024/01/02/Memory%20Cache/"},{"title":"二分图与图的连通","text":"update: 2023/12/12 fixed pictures 学习内容本周学习内容： 123456789101112131415161718192021222324252627282930313233343536Week 1|- 二分图| |- 二分图的判定| | |- 染色法| | |- 不存在奇环（长为奇数的环）| |- 二分图最大匹配（匈牙利算法）| |- 二分图最小点覆盖（König定理二分：二分图中，最小点覆盖=最大匹配）| |- 二分图最大独立集（二分图中，最大独立集=n-最小点覆盖）| |- 例题（关于建边）|- 图的联通| |- 定义（只有概念，详细定义见下）| | |- 无向图中的定义| | | |- 连通图| | | |- 子图| | | |- 连通子图| | | |- 连通分量（最大联通子图）| | |- 有向图中的定义| | | |- 强连通图| | | |- 强连通子图| | | |- 强连通分量| | | |- k连通图（双连通图）| | | |- 割点| | | |- 桥| | | |- 双连通分量| | | |- 点双连通分量| | | |- 边双连通分量| |- 算法| | |- 如何求强连通分量（SCC）= 如何缩点| | | |- Kosaraju算法| | | |- Tarjan算法| | | |- Gabow算法（略）| | |- 如何求桥/割点| | | |- Tarjan算法（对还是它）| | |- 如何求点/边双连通分量| | | |- Tarjan算法（啊？） 学习内容的模板（以及图论常用模板）二分图最大匹配（König算法）例题 12345678910111213141516171819202122232425vector&lt;int&gt; g[MAXN];bool vis[MAXM];int lst[MAXM];bool konig(int u) { for (auto &amp;v : g[u]) { // auto好用的 if (vis[v]) continue; vis[v] = 1; if (lst[v] == 0 || findargu(lst[v])) { lst[v] = u; return 1; } } return 0;}int main() { int cnt = 0; for (int i = 1; i &lt;= n; i++) { memset(vis, 0, sizeof vis); // 打时间戳可以优化常数 if (findargu(i)) cnt++; } cout &lt;&lt; cnt;} 强连通分量（SCC）以及缩点例题（附带最短路） 123456789101112131415161718192021222324252627282930313233343536373839404142vector&lt;int&gt; g[MAXN];int dfn[MAXN], low[MAXN], dfncnt; // 两个关键数组：dfn, lowbool ins[MAXN];int st[MAXN], top; // 手写栈int tag[MAXN], tagcnt; // 标记数组，tagcnt是强连通分量的个数void tarjan(int u) { dfn[u] = low[u] = ++dfncnt; ins[u] = 1; st[++top] = u; for (auto &amp;v : g[u]) { if (!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else if (ins[v]) low[u] = min(low[u], dfn[v]); } if (dfn[u] == low[u]) { tagcnt++; while (1) { int v = st[top--]; ins[v] = 0; tag[v] = tagcnt; if (v == u) break; } }}int main() { // 因为不确定图是否连通，所以对于每一个点都要跑一遍Tarjan for (int i = 1; i &lt;= n; i++) { if (!dfn[i]) tarjan(i); } // 缩点(建新图) vector&lt;int&gt; h[MAXN]; for (int i = 1; i &lt;= m; i++) { if (tag[e[i].u] != tag[e[i].v]) { h[tag[e[i].u]].push_back(tag[e[i].v]); } }} 割点例题 123456789101112131415161718192021222324252627vector&lt;int&gt; g[MAXN];int dfn[MAXN], low[MAXN], dfncnt;int tag[MAXN], tagcnt; // 求割点不需要使用栈// 割点bool cut[MAXN]; // 标记那些点是割点int cnt; // 统计割点个数void tarjan(int u, int f) { dfn[u] = low[u] = ++dfncnt; int sons = 0; for (auto &amp;v : g[u]) { if (!dfn[v]) { tarjan(v, u); sons++; low[u] = min(low[u], low[v]); if (low[v] &gt;= dfn[u] &amp;&amp; !cut[u] &amp;&amp; u != rt) { // 割点的判断-1 cut[u] = 1; cnt++; } } else if (dfn[v] &lt; dfn[u] &amp;&amp; v != f) low[u] = min(low[u], dfn[v]); } if (u == rt &amp;&amp; sons &gt;= 2 &amp;&amp; !cut[u]) { // 割点的判断-2 cut[u] = 1; cnt++; }} 桥例题（没有例题，不要点开） 1234567891011121314151617181920vector&lt;int&gt; g[MAXN];int dfn[MAXN], low[MAXN], dfncnt;int tag[MAXN], tagcnt; // 求桥还是不需要使用栈// 桥（输出到stdout）void tarjan(int u, int f) { dfn[u] = low[u] = ++dfncnt; int sons = 0; for (auto &amp;v : g[u]) { if (!dfn[v]) { tarjan(v, u); sons++; low[u] = min(low[u], low[v]); if (low[v] &gt; dfn[u]) { // 桥的判断 cout &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; endl; } } else if (dfn[v] &lt; dfn[u] &amp;&amp; v != f) low[u] = min(low[u], dfn[v]); }} 点双连通分量例题 123456789101112131415161718192021222324252627282930313233int dfn[MAXN], low[MAXN], dfncnt;int tag[MAXN], tagcnt;stack&lt;int&gt; st;int rt;vector&lt;int&gt; ans[MAXN];int cnt;void tarjan(int u) { dfn[u] = low[u] = ++dfncnt; st.push(u); if (u == rt &amp;&amp; !head[u]) { // 判断孤立点 ans[++cnt].push_back(u); return ; } for (int i = head[u]; i; i = g[i].nxt) { // 这里使用链式前向星 int v = g[i].to; if (!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); if (low[v] &gt;= dfn[u]) { cnt++; int p; do { p = st.top(); st.pop(); ans[cnt].push_back(p); } while (v != p); ans[cnt].push_back(u); } } else low[u] = min(low[u], dfn[v]); }} dijkstra算法例题0 例题1 例题2 （例题0是板子，例题1-2是缩点+最短路） 1234567891011121314151617181920212223242526272829303132// 值得注意的一点是，dijkstra算法处理最长路时会损失效率（虽然可以卡过），所以在处理最长路时使用SPFA会更加有效（尽管它死了）// 上述内容对应例题2，如果使用dijkstra算法的话会WA#3struct node{ int dis, u; bool operator &lt; (const node&amp; a) const { return dis &gt; a.dis; }};bool vis[MAXN];int dis[MAXN];priority_queue&lt;node&gt; q;void dijkstra(int s) { memset(dis, 0x3f, sizeof dis); dis[s] = 0; q.push({0, s}); while (!q.empty()) { int u = q.top().u; q.pop(); if (vis[u]) continue; vis[u] = 1; for (auto &amp;i : h[u]) { int v = i.first, w = i.second; if (dis[v] &gt; dis[u]+w) { dis[v] = dis[u]+w; q.push({dis[v], v}); } } }} SPFA算法例题0 例题1 （例题0是板子，例题1是缩点+最短路） 1234567891011121314151617181920212223242526272829303132// SPFA尽管死了并且它的效率要比dijkstra慢，但是其拥有良好的负环检测系统，关键是：最长路能用vector&lt;int&gt; h[500010];int dis[500010], cnt[500010];bool vis[500010];queue&lt;int&gt; q;// 这是最长路并且统计的是点权，改为最短路/统计边权只要参考dijhstra就好bool spfa() { memset(dis, -1, sizeof dis); // 最短路需改 int f = tag[s]; q.push(f); dis[f] = mon[f]; vis[f] = 1; while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (auto &amp;i : h[u]) { if (dis[i] &lt; dis[u]+mon[i]) { // 最短路/统计边权需改 dis[i] = dis[u]+mon[i]; // 最短路/统计边权需改 cnt[i] = cnt[u]+1; if (cnt[i] &gt;= tagcnt) return 0; if (!vis[i]) { q.push(i); vis[i] = 1; } } } } return 1;} 学习内容——各种定义强连通/连通图在无向图中，任意两点都直接或间接连通，则称该图为 连通图(connected). 相应的，有向图中任意一点都存在路径到达任意另一点，则称该有向图为 强连通图(strong connected) . 子图在一个图 $H$ 中，$H$ 的所有边属于图 $G$ 的所有边，$H$ 的所有点属于图 $G$ 的所有点，则称图 $H$ 是图 $G$ 的 子图(subgraph) . 连通分量无向图 $G$ 的最大连通子图称为 $G$ 的 连通分量(connected components) . 何为最大连通子图？这个子图是 $G$ 的连通子图，将 $G$ 的任何一个不在这张子图中的点加入这张子图后，该子图不再连通. 强连通分量（SCC）在任意有向图中能够实现强连通的部分我们称其为 **强连通分量(Strongly connected component)**，如下图，蓝色框内的分别是一个强连通分量. 如果把每个强连通分量收缩为单个顶点，得到的是一个 **有向无环图(DAG)**，于是我们可以在这个图的基础上进行拓扑排序，详见此例题. 而求这个强连通分量，我们可以使用两个算法：Kosaraju算法，Tarjan算法. Kosaraju算法的流程如下： 重复寻找图 $G$ 中未被讨论的点，从它开始DFS后序遍历图 $G$ ，遍历到的点置为已讨论，用数组记录每个点到达的先后次序，直到找不到没有讨论的点. 将图 $G$ 反向得到图 $G’$ ，重置所有点为未讨论. 一直从数组中未讨论的最后一个点出发，DFS后续遍历图 $G’$ ，DFS每完成一次，就说明找到了一个强连通分量，直到数组中没有未讨论的点. 这是Kosaraju算法的模板（之所以Kosaraju算法没有放在SCC的模板内，是因为这个算法相对于Tarjan算法少用很多）： 12345678910111213141516171819202122232425262728293031323334353637383940414243bool g[1001][1001]; // 这里使用的是邻接矩阵bool vis[1001];int lis[1001], cnt = 0;int tag[1001], scc = 0;bool ind[1001];void dfs1(int u) { vis[u] = 1; for (int i = 1; i &lt;= n; i++) { if (g[u][i] &amp;&amp; !vis[i]) dfs1(i); } lis[++cnt] = u;}void dfs2(int u) { vis[u] = 1; tag[u] = scc; for (int i = 1; i &lt;= n; i++) { if (g[i][u] &amp;&amp; !vis[i]) dfs2(i); // 这里注意，判断的边是g[i][u]，因为我们要在反图上跑dfs2() }}int main() { for (int i = 1; i &lt;= n; i++) vis[i] = 0; // 这里可以用memset for (int i = 1; i &lt;= n; i++) { if (!vis[i]) dfs1(i); } for (int i = 1; i &lt;= n; i++) vis[i] = 0; for (int i = cnt; i &gt;= 1; i--) { if (!vis[lis[i]]) { scc++; dfs2(lis[i]); } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if ((tag[i] != tag[j]) &amp;&amp; g[i][j]) { // 此处为缩点 } } }} 接下来我们来说说Tarjan算法，这个算法相对于上个算法理解起来要困难些. 在Tarjan算法中，最为重要的两个数组是 dfn[] 和 low[] ， dfn[i] 记录的是编号为i的节点在DFS的整个过程的顺序，它会在第一次访问到 $i$ 节点时更改，此后将不会变化；low[i] 表示的是 i 与其之后遍历到的节点所能到达的节点中 dfn 最小的 dfn ，在初始化时 dfn[i]=low[i] . Tarjan算法在运行时会生成一棵搜索树，但是我们知道，图!=树，因为图中有一些边会使得“树”有环，自然，在生成树后，有一些边会直接指向已遍历的节点，没遍历的节点会在下一步当作自己的孩子进行遍历，而指向已遍历节点的边就是导致“树”有环的罪魁祸首.按照定义，当发现有这种边的存在时，需要更新当前节点的 low[] 值，需要更新为 min(dfn[这些边指向的节点]) .而理所当然地，我们也要被孩子节点更新 low 值为 min(low[孩子节点]) . 现在我们聚焦某一个点 $i$，观察 dfn[i] 与 low[i] 的关系，以下是两种情况： dfn[i]&gt;low[i] ，这说明 $i$ 或其子孙节点存在边连到 $i$ 上方的节点. dfn[i]=low[i] ，这说明 $i$ 以及其子孙节点无法连到 $i$ 上方的节点，那么这个点 $i$ 就是一个强连通分量在这颗搜索树的根. 但是，$i$ 的子孙节点有可能会组成另一个强连通分量，这意味着 $i$ 的子树的节点不一定和 $i$ 处在同一个强连通分量内，我们需要 栈 来解决这个问题. 现在，我们用一张图看一下 dfn[] 与 low[] 的关系。 在这张图中，有 (3,4,5,6) ，7 ，8 ，1 ，2 这四个强连通块. 下图是Tarjan算法的运行过程. 因为SCC模板就是Tarjan算法，所以在这里不放代码. 二分图的最大匹配何为二分图？二分图是一种特殊的无向图，它的顶点可以被分为两个互斥的独立集 $U$ 和 $V$ 的图，使得所有边都是连结一个 $U$ 中的点和一个 $V$ 中的点（如下图所示）. 何为匹配？一个图的匹配是这个图中一些边所形成的集合，满足任意集合中的两条边都没有公共顶点. 解决这个问题的算法之一是匈牙利算法.在了解这个算法之前，我们先要了解一下何为增广路（增广轨/交错轨）. 增广路：若 $P$ 是图 $G$ 中一条连通两个未匹配顶点的路径，并且已匹配和未匹配的边（也就是属匹配边集 $M$ 的边和不属 $M$ 的边）在 $P$ 上交替出现，则称 $P$ 为相对于 $M$ 的一条增广路径. 不难发现，如果我们把 $P$ 中原来属于 $M$ 边从 $M$ 中删除，把 $P$ 中原来不属于 $M$ 边加入到 $M$ 中，变化后得到的新的匹配 $M’$ 恰好比原匹配多一条边. 而匈牙利算法就是不断寻找增广路 $P$ ，通过取反操作得到更大的匹配 $M’$ 来代替 $M$ . 代码如模板所示. 割点是无向连通图中一个顶点 $v$ , 如果删除它以及它关联的边后，得到的新图至少包含两个连通分量. 这里同样使用Tarjan算法. 思路和求SCC的Tarjan算法类似，这里直接给出结论： 一个顶点 $u$ 是割点，当且仅当满足条件 $1$ 或 $2$. $u$ 为树根，且 $u$ 有两棵及以上的子树（这很好理解吧）. $u$ 不为树根，且满足存在一条 $(u,v)$ 为树枝边使得 dfn[u] &lt;= low[v] ，即 $u$ 有一个孩子无法到达 $u$ 以上的点. 代码如模板所示. 桥是无向连通图中的一条边，如果删除它，得到的新图包含两个连通分量. 求桥和求割点差不多，可以直接从代码看出差别，而且判断条件的理解也和求割点差不多，此处不过多赘述. 双连通图不含割点的无向连通图. 双连通分量无向连通图的最大双连通子图. 点双连通分量通过找割点获得的双连通分量（层层递进.jpg 边双连通分量 （模板没打）通过找桥获得的双连通分量. 心得体会主要是图论之前有接触过，所以理解概念会比较快，同时在这一周我把之前一直没弄懂的Tarjan算法搞懂了. 现在的问题主要是建边的技巧以及破题的能力，像这种题（[SDOI2010]所驼门王的宝藏），这些建边的技巧想不到. 图论的常识有些遗忘了，例如Dijkstra跑最长路不能保证时间复杂度这类东西.","link":"/2023/07/08/%E4%BA%8C%E5%88%86%E5%9B%BE%E4%B8%8E%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A/"},{"title":"NKSWC2024游记","text":"拓扑排序定义拓扑排序是对其顶点的一种线性排序，使得对于从顶点 $u$ 到顶点 $v$ 的每个有向边 $u \\to v$ ，$u$ 在排序中都在 $v$ 之前。运行此算法需要保证图是DAG。 差分约束说白了，就是给出一个序列内数与数之间的关系，可能是大小关系，也可能是作差的数值，让我们尝试还原整个序列。 首先，这两种问题都得先转化成图上问题来做。 subtask 1：大小关系 考虑建图：设一条有向边 $u \\to v$ 表示 $b_u &gt; b_v$。有解时构建出来的图是一个DAG，并且如果在上面跑拓扑是能够确定所有 $b_i$ 之间的大小关系的；无解时，图上会存在一个环。 例题：数列恢复（半模板题），Pustynia（线段树优化）。 subtask 2：作差数值 这种情况需要使用最短路。鸽一会。 输出方案满足“尽量”关系首先我对于这个方案有一个谁在谁前面有很多个限制。 大致如下： 在满足所有限制的前提下，$1$ 尽量靠前。 在满足所有限制，$1$ 尽量靠前的前提下，$2$ 尽量靠前。 在满足所有限制，$1$ 和 $2$ 尽量靠前的前提下，$3$ 尽量靠前。 在满足所有限制，$1$ 和 $2$ 和 $3$ 号尽量靠前的前提下，$4$ 尽量靠前。 以此类推。 很多人可能认为这就是字典序，其实不然。考虑这组数据： 123456 45 44 26 33 1 以及 123456 45 33 16 44 2 这里放个结论：最终的序列是满足限制的前提下字典序最大的倒序。 有大佬证明了，在这里贴个链接。 例题：菜肴制作（板）。 二分图的判定染色。 欧拉路最灵活的一集。 首先是如何判欧拉通路和欧拉回路以及证明。 Theorem 1 无向连通图中存在欧拉回路当且仅当图中所有顶点的度数为偶数。 充分性：欧拉回路从起点出发对起点产生 $1$ 的度数，而后经过的除终点（也就是起点）外每一个点产生 $2$ 的度数，最后回到起点又对起点产生 $1$ 的度数。 必要性：考虑使用构造法证明。我们每次在图中寻找一条回路，如果这个回路是欧拉回路，那么结论成立；否则删除环上所有的边以及一些孤立点，明显剩下的这个子图的所有点的度数都是偶数但可能不连通，并且这个子图一定和找到的回路有一个公共点，那么再次以这个公共点为起点继续寻找回路并重复以上过程直到找不出来为止。找完后将这些回路串起来就是最终的欧拉回路了。 Theorem 2 连通多重图中存在欧拉通路且不存在欧拉回路当且仅当连通图中有且只有两个顶点的度数为奇数。 证明过程和上面的类似，这里不做阐释。 而如何跑欧拉路，上面证明给出的构造方案已经说得很清楚了。 例题：POLICE（很难看出来这是一道欧拉路的题目），丁香之路（与MST相结合）。 看到图论题不会做就想想能不能欧拉回路。 ——0htoAi 最小生成树最小生成树大多数时候用的是它的一个思路，毕竟人家不太可能把板子明摆着让你写。 有两个算法，但是两个算法的本质都是贪心。 Kruskal将所有边按边权从小到大排序，再依次加边，并用并查集维护是否会出现环，如果加入一条边后有环则不加。正确性显然。 如果有边是必选的话就可以提前在并查集里加边，后续不用做任何更改。 时间复杂度：$O(m \\log m)$ 谁完全图用这个算法我笑他一辈子。 例题：丁香之路（与欧拉回路相结合） Prim从一个点开始每次选择与这个点相邻的最短的一条边，加入这条边和对应的点，再找距离这两个点最近的其他点进行添加，以此类推。 时间复杂度：$O(m \\log n)$ 图的连通性这个知识点之前写过，这边建议出门左转二分图与图的连通。 例题：未整理。 耳这个知识点在NKSWC的第【数据删除】场测试中出现了，因此咕一下（什么逻辑）。 并查集几个小技巧。 删边倒序处理如果出现删边类型操作的话，可以将询问离线下来倒着处理。 删点=新点如果删除一个点之后不会出现任何与这个点有关的操作的话，可以记录一个 $id$ 数组，删点就直接弃用之前的点并建立新点。 撤销操作注意数据范围。建边时记录操作序列，每次回溯直接重置 $fa_i$ ，这意味着并查集将不能路径压缩或按秩合并。 例题：没有。 单调/优先队列单调队列优化DP当状态转移是下面这种形式时，可以使用单调队列进行优化。 $$f_i=\\max_{j=l}^r f_j+val(i,j)$$ 即用单调队列维护 $j$ 的值，最终状态从单调队列的队尾转移。 例题：未整理。 带悔贪心目前我见过的这种类型的题目用一只手都能数过来。 简单而言，就是把选和不选的情况分开考虑，一个直接贪心，另一个放到单调队列里等待后面取出。而一个不选的状态的代价是扣除选的价值再加上不选的价值。总之就是一个字：抽象。 这种题目应该是做多了才能看的出来吧。 例题：数据备份。 线段树线段树优化建图用线段树上的点来凑出一个区间。 如果有区间连点和点连区间同时出现的话要建立两棵树，一个负责入，一个负责出。 要考虑好大区间与小区间是否有关系，如果有也需要建边（目前来看都是有的）。 例题：Pustynia（与差分约束结合）。 题目专版数列恢复 有一个序列 $a$，长度为 $n$，且对于任意一个 $i(1 \\leq i \\leq n)$ 满足 $|a_i| \\leq n$，定义 $s_{i,j} = a_i + a_{i+1} + … + a_j$，现在给定所有 $s_{i,j}(1 \\leq i \\leq j \\leq n)$ 的正负性，输出任意一个合法的 $a$ 序列。 然而这道题给的是每段区间和 $0$ 的大小关系，无法转换到上述模型。因此我们考虑将原式中的 $s_{i,j}$ 转化为前缀和形式：$s_{i,j}=sum_{j}-sum_{i-1}$，这样就能转换了。套用模型，最后能够处理出来每个 $sum_i$ 的大小关系。 有一点细节是当 $s_{i,j}=0$ 时，也就是 $sum_{i-1}=sum_{j}$，跑拓扑更新到这两个点中的任意一个时要同步更新另一个。 Pustynia 给定一个长度为 $n$ 的正整数序列 $a$，每个数都在 $1$ 到 $10^9$ 范围内，告诉你其中 $s$ 个数，并给出 $m$ 条信息，每条信息包含三个数 $l,r,k$ 以及接下来 $k$ 个正整数，表示 $a_l, a_{l+1}, \\ldots, a_{r-1}, a_r$ 里这 $k$ 个数中的任意一个都比任意一个剩下的 $r-l+1-k$ 个数大（严格大于，即没有等号）。需要任意构造出一组满足条件的方案，或者判断无解。 这一道题和这道题差不多，都是建图跑差分约束模型，但是此题需要使用线段树优化建图。 菜肴制作 给定 $n$ 个菜肴和 $m$ 条限制条件，对于每个限制条件 $x$ 和 $y$，表示 $x$ 号菜肴必须先于 $y$ 号菜肴。让你求出在满足最小号的菜肴尽量靠前的前提下次小号的菜肴也尽量靠前，次小号的菜肴尽量靠前的前提下次次小号的菜肴也尽量靠前，并以此类推。（注意不是字典序！）以此类推，最优的菜肴制作顺序。如若无解，则输出 Impossible! 。 如题。 POLICE 有一个 $n \\times m$ 的矩阵，每个位置上有一个数，现在要将这个矩阵通过两种操作还原成初始状态，保证原矩阵里的数和现在的数一致。 操作1：交换同行两个相邻位置上的数。 操作2：交换任意两个位置上的数。 请求出需要的执行操作2的次数最少是多少，或者输出无解。 先把例题摆着，因为这道题我也没过。 丁香之路 数轴上有 $n$ 个点，表示的数分别是 $1\\sim n$，有 $m$ 条连接两个点的边（独立于数轴的），这些边必须走一遍，求 $s$ 到其他点的最短路。 搁置一下。 数据备份搁置一下。","link":"/2024/02/04/NKSWC2024%E6%B8%B8%E8%AE%B0/"},{"title":"区间DP总结","text":"考试总结Task 1正解性质题，找规律。 规律如下： 从 $n=15$ 开始：$108,188,200,208,288,688,888,1088,1888,2008,2888,8888\\dots$ 容易发现 $a_n=a_{n-7}\\times10+8\\quad(n \\geq 22)$ 前14个要特判。 代码1无 关键点暴力找规律。 死因20 开头的规律没找到，就是没打暴力找规律。 Task 2正解搜索。 优化这道题可以用 十字链表（Dancing Links X） 加速，但是爆搜就能跑出 $400\\text{ms}$ 的好成绩。 别名：双向循环十字链表。 为什么能跑这么快关键点： 对于这种搜索时间最不利的是 $5 \\times 6$ 的矩阵，并且是无解的情况。 正常来说，如果不要求不能重复走点，时间复杂度最坏为 $O(2^{4} \\times 3^{14} \\times 4^{16})$ ，即四个角（4个）上的点有两种走法，边上的点（14个）有三种走法，内部的点（16个）有四种走法。 但是不能重复走点的情况下，时间复杂度最坏为 $O(1^{4} \\times 2^{14} \\times 3^{16})$，但是考虑到实际情况，加一个可行性剪枝，最后 $\\text{dfs()}$ 函数大概只会运行到 $5 \\times 10^6$ 次。 爆搜敢冲就能过。 题目来源《永远的七日之都》 代码1无 死因1for (int i = 0; i &lt;= n; i++) // wssb Task 3正解以 $dp$ 为辅助的搜索题。 说真的，这道题不难。一切的思路都是自然而然的，从爆搜到可行性剪枝再到用 $dp$ 完成可行性剪枝，最后实现的代码难度也不高。 关键点$dp$ 可能不是一道题的全部而是一道题的部分。 思路 先想爆搜，同一位按字典序从大到小搜，期望得分：$30-40;pts$。 再想剪枝，用 $dp$ 判定后面有没有可能有解，计算一个点后最多能获取到的权值，再加上已经搜到的权值看它能不能 $\\geq x$ 。 怎么做 $dp$ ？记录 $dp$ 长度和最后一位，预处理 $dp$ 时间复杂度为 $O(4n)$ 。整个算法时间复杂度见课后思考。 课后思考 整体时间复杂度是 $O(n+k)$ 还是 $O(nk)$ ？理论分析应该是 $O(n+k)$ 。 代码1无 死因并没有死，打了暴力。还是全场唯一得分点（$30;pts$）。 但是事实上我的暴力打得还有优化空间且有一个小问题。 Task 4正解区间 $dp$ 。 思路 考虑朴素区间 $dp$ ，对于每个 $l\\sim r$ 区间，枚举小区间并转移，时间复杂度 $O(n^4)$ 。 但是这种做法会 $\\text{WA}$ 掉，因为这样记录状态会有情况没考虑到。所以考虑重设状态 $f_{i,j,max,min}$ 表示区间 $i\\sim j$ 内已经通过多次操作后剩下的最大值为 $max$ 、最小值为 $min$ 时，所花的最小代价。而后我们定义 $ans_{i,j}$ 为 $i\\sim j$ 这段区间被选空的最终答案（就是题目中说的那个最后输出的答案）。 接下来考虑怎么转移。$ans_{i,j}$ 的转移很简单，就是 $ans_{i,j}=max(f_{i,j,max,min}+a+b\\times(max-min))$ 。而 $f_{i,j,max,min}$ 的转移，首先应该枚举中间断点 $k$ 就应该有以下三种情况： $min$ 与 $max$ 都在左边，右边被选空：$f_{i,j,max,min}=f_{i,k,max,min}+ans_{k+1,j}$ 。 $min$ 与 $max$ 都在右边，左边被选空：$f_{i,j,max,min}=ans_{i,k}+f_{k+1,j,max,min}$ 。 $min$ 与 $max$ 左右两边都有：$f_{i,j,max,min}=f_{i,k,max,min}+f_{k+1,j,max,min}$ 。 容易发现的是，这样转移肯定不会少考虑情况，接下来就是考虑这么转移是否会多考虑情况？如果多考虑了，对答案有没有影响？ 【这里不会】（zhw看到了comment一下） 结论：会多考虑情况但是这些情况不会比答案更优。 注意点：$w_i \\leq 1000$ ，需要离散化处理。 来源THUSC 2016 成绩单 代码1无 区间DP总结 区间DP是变化之神！ $\\text{Link Start!}$ 通过例题看看区间DP的一些套路和新的思路。 不如按题目分类来说。 A~E 普通/模板区间DP 能量项链——普通区间DP 石子合并（加强版）——四边形不等式优化（不要求掌握） 【USACO 3.3.5】A Game游戏 IOI’96——带了博弈论的区间DP（个人觉得有点意思） 做错的作业——括号匹配类型的区间DP 【CQOI 2007】涂色——涂色类型区间DP F,G 凸多边形区间DP这一类型的DP特点是建立模型比较难。 要点梳理： 无论从哪一个点开始都一样，因此不必拆环成链。 状态定义为：$f_{i,j}$ 表示将 $i\\sim j$ 这一段点的区间转化为三角形的最小价值。 状态转移为：$f_{i,j}=\\min(f_{i,j},f_{i,k}+f_{k,j}+\\text{cost}(i,j,k))$ ，即 $k$ 是两个子区间的公共端点， 而将他们合并后能组合出新的三角形 $\\Delta A_iA_jA_k$ ，因此要加上这个新三角形造成的权值。 H 字符串折叠我认为这道题的思路是捋得最清的，因为这道题真的很简单。 大致思路就是有两种转移：一是组合两段已压缩的区间，二是将这段区间压缩，时间复杂度大致为 $O(n^4)$ ，能刚刚好卡着过（据说用预处理或哈希或KMP找最长重复子串的长度能够将这道题卡到 $O(n^3)$ 的时间复杂度，然鹅我不会）。 R 压缩这也是一道压缩字符串的题目。 但是这里对 $M$ 和 $R$ 的处理要更为复杂。 具体而言，这道题的 $f_{i,j,k}\\quad(1\\leq i\\leq j\\leq n,k\\subset{0,1})$ 多了一维，用于标记 $i\\sim j$ 这段区间内是（$1$）否（$0$）存在 $M$ 。 状态转移： $f_{i,j,0}=f_{i,k,0}+j-k$ $f_{i,j,1}=\\min(f_{i,k,0},f_{i,k,1})+\\min(f_{k+1,j,0},f_{k+1,j,1})$ $f_{i,j,0}=f_{i,mid,0}+1\\quad\\text{when }[i,j]\\text{ can compress}$ J 表达式的亿种可能性最有意义的题目之一。 维护的 $f_{i,j}$ 就是答案所求，关键就在转移。 弄清楚以下几点： $\\times$ 的转移不需要别的东西，只需要 $f_{i,j}=f_{i,k}\\times f_{k+1,j} \\times\\text{val}$ $+$ 和 $-$ 的转移需要考虑左边的括号个数和右边的括号个数（详见第一次提交内的代码推导），最终转移式为：$f_{i,j}=((j-k-1)!f_{i,k}+(k-i)!f_{k+1,j})\\times\\text{val}$ 但是以上转移式只考虑了先放完左边的括号再放右边的括号，然而，我们可以左右交替来回放，并且，左边内括号的顺序已经是我们在 $f_{i,k}$ 中内定好的了。因此 $\\text{val}=\\frac{(j-i-1)!}{(k-i)!(j-k-1)!}$ 作为系数。 M 有味道的数字最具有启发性的一题。 这道题有几个性质需要搜索搜出来——只有 $3$ 和 $7$ 无法表示，表示 $5000$ 以内的数字最多只会用到长度为 $11$ 的前缀。 $f_{i,j}$ 表示 $i\\sim j$ 这段区间内能表示出来的值（是个数组）这种思想有个很NB的名字叫做 **离散_____**（人话：打表）。 即用 $\\text{vector}$ 存储值，单次转移时间复杂度就是 $O(nm)$ （ $n,m$ 表示合并的两个 $\\text{vector}$ ） ，玄学下降！ 而转移嘛……人人都会。 Q 单调栈搜索最上牌面的一题。 这道题思路没什么好说的，只是注意一下有的时候记忆化搜索比循环区间DP好写。 区间DP的一点小知识我个人一般会这么打区间DP： 123456for (int len = 2; len &lt;= n; len++) { for (int i = 1; i+len-1 &lt;= n; i++) { int j = i+len-1; // ... }} 然而这么打常数是比较大的，优化写法： 12345for (int j = 2; j &lt;= n; j++) { for (int i = j-1; i &gt;= 1; i--) { // ... }} 据说这样能优化很多。 我认为区间DP还有一类很重要的题，典型例题：关路灯 区间DP的特征 在操作中需要将两端区间合并，合并时存在固定的转移关系。 在操作中需要将子区间转移。 怎么看需不需要多开维数很明显，当目前的状态定义会出现明显重复统计或是限制条件不够时要多开空间。","link":"/2023/12/04/%E5%8C%BA%E9%97%B4DP%E6%80%BB%E7%BB%93/"},{"title":"动态规划","text":"动态规划（Dynamic programming）是一种神奇的喵。 动态规划的基本性质以及几个重要概念 忘记过去的人，必定要重蹈覆辙。 ——乔治·桑塔亚纳 几个性质 最优子结构这个特性也会在贪心算法中出现。 无后效性已经求解的子问题，不会再受到后续决策的影响。 子问题重叠见上文引用。 几个重要概念 状态即 dp 数组中每个位置的含义。 状态转移方程单纯讨论 dp 数组中的状态的转移关系，这一步将会非常关键。 初始状态定义也就是一开始的时候，哪些状态的值是可以直接确定的并且在状态的转移中无法被计算甚至会影响状态转移的。（我有很多次都是因为 dp 初始值导致来回调代码） 接下来我们会用一道题目来看一下这些定义是什么。 简单例题 IOI1994 数字三角形简单来说，给定一个由数组成的三角形（即除第一层只有一个数外，每一层的数个数都比上一层多1），需要你求出从第一层到最后一层的所经过的最大的和。例如这个三角形，从 $7→3→8→7→5$ 的路径产生了最大权值。 这道题很简单，所以只在此处明确一下以上的概念。下文中的 dp 数组未经优化，是二维数组，并且思路是从上往下进行计算。 状态：dp[i][j] 表示从上往下走到第 i 行第 j 列所能得到的最大权值。 状态转移方程：dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + a[i][j] 初始状态定义：dp[1][1] = a[1][1]（但其实定不定义无所谓的啦） 喵你已经掌握了这些基本概念了，接下来我们会各种形态的DP进行深入剖析喵 各种动态规划的形态线性DP这一种DP构造最简单，代表性问题是LIS(最长上升子序列)和LCS(最长公共子序列)。(因为连续序列太简单，所以不在此处讨论) 最长公共子序列(LCS)我们定义 f[i][j] 为第一个数组 i 之前与第二个数组 j 之前的数能构成的最长公共子序列的长度。于是，稍加推导，可以得出状态转移方程： $f_{i,j}=\\begin{cases}f_{i-1,j-1}+1&amp;\\mathrm{if}\\;s[i]=t[j]\\\\max(f_{i-1,j},f_{i,j-1})&amp;\\mathrm{otherwise.}\\end{cases}$ （这应该看得懂吧。。。） 接下来考虑初始状态，很明显，根本不需要定义初始状态。 接下来就是考验码力的时候了（好像也不怎么考验？ P.S. 如何提升码力？多做模拟题，尤其是大模拟，成为码力小王子！（我都没做 * So, end? * Yeah, it’s easy. Isn’t it? 最长上升子序列(LIS)请注意，LIS题目中还有很多类型的，例如求方案数或是判断一个数是否一定属于它所在的数组的LIS中。 我们定义 f[i] 表示前 i 个元素的最长上升子序列的长度。更新时，使用前面的所有合法状态来更新当前状态，容易写出转移方程： $ f_{i}=\\mathrm{max}(f_{j}\\;|\\;j&lt;i\\;\\mathrm{and}\\;A_j&lt;A_i) $ 这种方法的时间复杂度是 $O(n^2)$ ，并且我们还有第二种方法，它的时间复杂度是 $O(n\\log n)$ 的。 首先我们定义一个数组 $d$ ，表示最长上升子序列，$len$ 为这个最长上升子序列的长度，所以 $d_{len}$ 就是这个最长上升子序列的最后一个元素。 我们初始化状态：$d_1=a_1, len=1$ 接下来我们枚举 $i$ 从 $2$ 到 $n$ 每次更新 $d$ 数组。考虑接下来添加一个元素 $a_i$： 如果这个元素 $a_i \\geq d_{len}$ ，就直接向最后添加一个元素。 否则我们在数组 $d$ 中找到第一个大于 $a_i$ 的元素与 $a_i$ 作替换。 完成！ 背包问题事实上在这个子问题下还有很多类问题，但是这类问题很简单，也肯定有人比我写得好，就不在此处说明了。 记忆化搜索很难说它属于DP，但是它的思想却是实打实的DP。我们可以把这个词分为两块来理解：记忆化+搜索。还记得 Part 1 引用的那句话吗，记忆化搜索就是为了防止搜索时出现重复状态增加运行时间而出现的。具体而言，它在搜索过程中记录了每一步得到的答案，而下次这个同样的情况被搜索到时，将不会继续搜索，而是会把之前记录的答案直接返回。 这类问题有很多，包括后文中提到的 数位DP 的例题也是使用了记忆化搜索的。 解题步骤 先看这道题能不能用记忆化搜索（这要保证搜索时产生的状态并不多）。 如果可以，那么应该如何定义状态，需要记录的到底有什么（例如搜索时产生的步数信息就 一般 不用记录）。 我下次复用这个信息的时候要注意什么。 区间DP这类题目算是 玩的挺花 的题，各种变形出其不意攻其不备，并且状态的定义会比其他类型的题目灵活许多，因此对于这些题，最好的方法不是记模型，而是理解这种思路。因此，这个板块我们需要结合例题来看。 最经典的区间DP例题——石子合并（弱化版） 一条路上有许多堆石子，每堆石子都有一个质量参数，现在要将它们合并成一堆，每次合并的代价是这两堆石子的质量之和，需要求出合并成一堆的总代价的最小值。 题意很简单，现在我们来考虑状态的定义：$f_{i,j}$ 表示合并第 $i$ 到第 $j$ 堆石子所花费的代价的最小值。 接下来我们考虑转移：从 $i$ 到 $j$ 的石子可以把它分成两半来考虑，每次转移只需要增加两边的代价，也就是 $f_{i,j}=\\mathrm{min}(f_{i,k}+f_{k+1,j}\\;|\\;i \\leq k\\leq j-1)$ （注意这个 $-1$ 哈） 那么，问题来了，$f$ 想要转移，前提是那些转移来的值是已经被处理过的，否则转了跟转了一样（sssss），所以，我们需要一种枚举方法，来保证转移的合法性。 这里你可以参考 floyd 的转移方法（事实上有人说 floyd 也是DP），我们只需要先枚举区间长度，再枚举起点，最后用前两个信息推出区间终点，我们考虑一下为什么这么做可以满足上面的性质，因为我们每次转移来的两个区间的长度一定是比当前区间的长度短的，而我们的区间长度又是从小到大枚举，自然而然转移来的状态一定是已经处理过的了。 另外，我们每次加的代价值，不能 再拿一个循环来枚举并累加代价，这里我们需要预处理一个前缀和以便我们在 $O(1)$ 的时间内的到代价值。 最后是初始状态，$f$ 数组首先肯定要赋值成极大值（这里注意，不建议将其赋值成 INT_MAX 或 LLONG_MAX ，这样 $f$ 数组一加就直接爆 int 或 long long，虽然这道题可以这么赋值），然后对于对角线上的元素 $f_{i,i}$ 要赋值成 $0$ 。 思考过程结束，代码如下。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;climits&gt;using namespace std;int n, a[301];int dp[301][301];int c[301];int main() { cin &gt;&gt; n; for (int i = 0; i &lt;= n; i++) { for (int j = 0; j &lt;= n; j++) { dp[i][j] = INT_MAX; } } for (int i = 1; i &lt;= n; i++) { dp[i][i] = 0; } for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; c[i] = c[i - 1] + a[i]; } for (int len = 2; len &lt;= n; len++) { for (int i = 1; i &lt;= n; i++) { int j = i + len - 1; if (j &lt;= n) { for (int k = i; k &lt; j; k++) { dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + c[j] - c[i - 1]); } } } } cout &lt;&lt; dp[1][n];} 这道题事实上可以使用四边形不等式优化。但是我也忘了qwq。","link":"/2023/07/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"分块与矩阵","text":"update: 2023/12/12 fixed pictures 本文中所有图片均使用Power Point制作 分块部分俗话说得好： ${ \\Huge 暴力+暴力=分块 }$ 分块总的来说就是线段树的阉割版，其时间复杂度基本维持在 $\\sqrt N$ 数量级。一般的分块支持单点/区间查询以及单点/区间修改. 分块的块长一般是 $\\sqrt N$ ( $N$ 是数组大小)，例如，对于一个数组 $A$ ，$|A| =13$ ，每一块的长度便是 $\\sqrt {13}\\approx3$ ，但是分块完成后我们会发现最后一块的大小是 $1$ ，不足其他块的大小(如下图). 分了块后我们便可以干很多事了，单点查询/修改就不说了，直接访问数组下标进行修改.我们来说说区间查询/修改，例如还是那个数组 $A$ ，现在我们要修改下标为 $2$ 到 $7$ 的区间，这个时候我们要对每一块生成一个懒标记，于是我们的思路便很明确了，对于这段区间里整块的部分直接修改懒标记，剩下的不足一整块暴力修改(如下图).同理，查询也是一样，只是要注意统计时要把所有懒标记加上，不管是整块还是不足整块.下面也会给出一份区间修改(增加)区间查询(最大值)的代码. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3fffffff;int n, m, s;int a[100100], chunk[100100], lazy[100100];void modify(int x, int y, int z) { int i = (x-1)/s+1; int j = (y-1)/s+1; chunk[i] = -inf; chunk[j] = -inf; if (i == j) { for (int k = x; k &lt;= y; k++) { a[k] += z; } for (int k = (i-1)*s+1; k &lt;= j*s; k++) { if (a[k] &gt; chunk[i]) chunk[i] = a[k]; } } else { for (int k = x; k &lt;= i*s; k++) { a[k] += z; } for (int k = (i-1)*s+1; k &lt;= i*s; k++) { if (a[k] &gt; chunk[i]) chunk[i] = a[k]; } for (int k = (j-1)*s+1; k &lt;= y; k++) { a[k] += z; } for (int k = (j-1)*s+1; k &lt;= j*s; k++) { if (a[k] &gt; chunk[j]) chunk[j] = a[k]; } for (int k = i+1; k &lt; j; k++) { lazy[k] += z; } }}int search(int x, int y) { int i = (x-1)/s+1; int j = (y-1)/s+1; int ans = -inf; if (i == j) { for (int k = x; k &lt;= y; k++) { if (a[k]+lazy[i] &gt; ans) ans = a[k]+lazy[j]; } } else { for (int k = x; k &lt;= i*s; k++) { if (a[k]+lazy[i] &gt; ans) ans = a[k]+lazy[i]; } for (int k = (j-1)*s+1; k &lt;= y; k++) { if (a[k]+lazy[j] &gt; ans) ans = a[k]+lazy[j]; } for (int k = i+1; k &lt; j; k++) { if (chunk[k]+lazy[k] &gt; ans) ans = chunk[k]+lazy[k]; } } return ans;}signed main() { scanf(&quot;%d&quot;, &amp;n); s = sqrt(n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, a+i); if (i%s == 1 || a[i] &gt; chunk[(i-1)/s+1]) chunk[(i-1)/s+1] = a[i]; } cin &gt;&gt; m; while (m--) { char op[3]; int x, y, z; scanf(&quot;%s%d%d&quot;, op, &amp;x, &amp;y); if (op[2] == 'D') { cin &gt;&gt; z; modify(x, y, z); } else { cout &lt;&lt; search(x, y) &lt;&lt; endl; } }}/*Input:51 2 3 2 55ADD 1 4 3ASK 2 3ASK 3 5ADD 2 4 2ASK 2 5Output:668*/ 分块的大部分题目并不像这样简单，例如下面的动态区间第 $K$ 小数例题. 给定一个由 $N$ 个数组成的序列 ${A_1,A_2,…,A_N}$每次可以将 $A_k$ 的值改为 $t$ ，或者提问序列中 ${A_l,..,A_r}$ 中第 $k$ 小的数的值. 对于这道题，我们需要使用另一个数组 $B$ 用来将每个块内的元素排序，需要查询时先使用二分答案，再在 check() 内对于整块的统计答案直接使用排序的数组进行二分，正所谓一个分块套二分再套二分，细节很多，详见下码. 123456789101112131415161718192021222324252627282930313233343536373839404142void modify(int k, int t) { // 单点修改，需要排序 int F = (k-1)/s+1; a[k] = t; b[F].clear(); for (int i = (F-1)*s+1; i &lt;= F*s; i++) { b[F].push_back(a[i]); } sort(b[F].begin(), b[F].end());}int check(int x, int y, int f) { // 统计信息 int i = (x-1)/s+1; int j = (y-1)/s+1; int ans = 0; if (i == j) { for (int k = x; k &lt;= y; k++) { if (a[k] &lt; f) ans++; } } else { for (int k = x; k &lt;= i*s; k++) { if (a[k] &lt; f) ans++; } for (int k = (j-1)*s+1; k &lt;= y; k++) { if (a[k] &lt; f) ans++; } for (int k = i+1; k &lt; j; k++) { ans += lower_bound(b[k].begin(), b[k].end(), f) -b[k].begin(); // 直接二分统计整块内的答案 } } return ans;}int query(int x, int y, int k) { // 二分答案 int l = 0, r = 50005, mid; while (l+1 &lt; r) { mid = (l+r)&gt;&gt;1; if (check(x, y, mid) &gt;= k) r = mid; else l = mid; } return l;} 除此之外，还有要同时开两个 lazy 的题目——数列分块入门7，关键在于处理两个运算法则之间的优先级. 数列分块入门5——在根号开到一定程度时块内的元素会全部变为 $1$，这时可以不用暴力统计，直接计算块长. 另外，还有一类分块题，算是属于半个块状数组(或者说块状链表). 众所周知，数组访问时间复杂度 $O(1)$ ，修改 $O(n)$ ，而链表访问 $O(n)$ ，修改 $O(1)$ . 而块状链表，就是两者的结合体，它查询 $O(\\sqrt n)$ ，修改 $O(\\sqrt n)$ ，两者时间复杂度相差不大，是个折中方案，具体长什么样见下图. 那我们应该如何维护来保证它们的时间复杂度呢？很简单，我们只需要在一个块的大小大于一定的值后暴力拆分成两块接在原块后面（什么细胞的无丝分裂，具体来说，我们要在一块的大小大于 $2\\sqrt N$ 时分裂(注意：此处的 $N$ 指的是所有元素，包括了后面新增的元素，也就是说每次添加元素时要重新计算阈值长度).理清思路后，代码实现很简单了(见下，例题). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int cnt; // 总块数，用于给新块编号int nc; // 元素总数typedef pair&lt;int, int&gt; pii; // 不会吧不会吧，都3202年了不会还有人不会用typedef吧pii locate(int x) { // 定位元素 int i = 1; while (x &gt; block[i].siz) { x -= block[i].siz; i = block[i].to; } return {i, x};}void split(int x, int y) { cnt++; for (int i = y; i &lt;= block[x].siz; i++) { block[cnt].a[++block[cnt].siz] = block[x].a[i]; block[x].a[i] = 0; } block[cnt].to = block[x].to; block[x].to = cnt;}// 临时定义一下（不要问我为什么不开变量#define x p.first#define y p.secondvoid insert(int t, int v) { pii p = locate(t); // 暴力插入 for (int i = block[x].siz; i &gt;= y; i--) { block[x].a[i+1] = block[x].a[i]; } block[x].siz++; block[x].a[y] = v; nc++; s = sqrt(nc); if (block[x].siz &gt;= 2*s) { split(x, block[x].siz/2+1); block[x].siz = block[x].siz/2; }}#undef x#undef yint query(int x) { // 极简的查询的函数 pii p = locate(x); return block[p.first].a[p.second];} 除了一般的分块题和块状链表外，分块还有一个重要作用——莫队，它可以解决一部分的区间查询题目(尤其是查询某种区间有几种值的). 先说本质，本质并不是分块，而是双指针.莫队在运行时会用到两个数组，一个是原来的数组，另一个是 cnt 数组，cnt 数组是用来记录每个数出现的次数(在某些时候可能需要配合离散化食用).下面是算法基本的运行过程. 首先我们有两个指针 i 和 j ，先不考虑为什么他们在这个位置上，现在我们要把他们移到既定位置.我们有一种很简单的思路，先把左( i )移到既定位置的左端点，再把右( j )移到既定位置的右端点上.而在这个期间，我们可以顺便统计 cnt 数组，并且维护 tot 变量(统计种类，具体来讲是在 cnt 某个值从0到1或是从1到0的过程中修正).于是我们就有了一个基本的模型了，就是不断通过移动双指针来处理每个询问，但是很明显，这样移来移去，i 最多会移动 $MN$ 次( $M$ 是询问次数，$N$ 是数组长度)，j 也同理，这样的时间复杂度是不行的.而莫队算法就是在此处做了优化. 莫队首先会把询问离线，并把数组的点进行分块，而排序询问的第一关键字是每个询问左端点所在块的编号，而第二关键字是右端点.具体实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, s;int a[50050], cnt[1000010];int ans[200020], tot = 0; // ans是将答案还原的数组struct node { int l, r, id;} q[200020];bool cmp(node a, node b) { if ((a.l-1)/s+1 == (b.l-1)/s+1) return a.r &lt; b.r; // 排序 return a.l &lt; b.l;}void add(int p) { if (++cnt[a[p]] == 1) tot++; // 对应左端点左移与右端点右移}void del(int p) { if (--cnt[a[p]] == 0) tot--; // 对应左端点右移与右端点左移}signed main() { cin &gt;&gt; n; s = sqrt(n); for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; } cin &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; q[i].l &gt;&gt; q[i].r; q[i].id = i; } sort(q+1, q+m+1, cmp); // 处理询问 int l = 0, r = 0; for (int i = 1; i &lt;= m; i++) { while (r &lt; q[i].r) add(++r); while (r &gt; q[i].r) del(r--); while (l &lt; q[i].l) del(l++); while (l &gt; q[i].l) add(--l); ans[q[i].id] = tot; } for (int i = 1; i &lt;= m; i++) { cout &lt;&lt; ans[i] &lt;&lt; endl; } return 0;} 除此之外，莫队还有一种带修改版本. 不是说了将询问离线了吗，离线处理时怎么修改啊. 还是可以修改的，现在带修改功能得将修改的点还原到询问前的状态. 现在时间也得移来移去了. 嗯？时间移来移去？像 i 和 j 那样？ 那这就好实现了啊.新增一维来处理时间. 具体怎么讲？ 记录一下每次修改前后的状态，每次将时间移动时便一步步更换状态，直到回溯到指定时间，同时 cmp 函数也要改一下. 于是，我们就有了这个代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;// 回避关键词检测的打包函数#define pack1 {x, y, ccnt, qcnt}#define pack2 {x, y}using namespace std;int l, r;int n, m, s, tcnt;int a[133344], cnt[1000010];int ans[133344], tot;int chunk[133344];struct node{ // 记录询问 int l, r, t, i;}q[133344];int qcnt;bool cmp(node a, node b) { // 新的排序函数 if (chunk[a.l] == chunk[b.l] &amp;&amp; chunk[a.r] == chunk[b.r]) return a.t &lt; b.t; if (chunk[a.l] == chunk[b.l]) return a.r &lt; b.r; return a.l &lt; b.l;}struct cg{ // 记录修改 int i, v;}c[133344];int ccnt;void add(int p) { tot += !cnt[p]++; // 用于l与r的修改，意义同上}void del(int p) { tot -= !--cnt[p]; // 同上}void timem(int i, int p) { if (q[i].l &lt;= c[p].i &amp;&amp; c[p].i &lt;= q[i].r) { // 时间更改器（雾 del(a[c[p].i]); add(c[p].v); } swap(a[c[p].i], c[p].v); // 因为有去必有回，所以下一次使用这个位置一定是把它更改回来}int main() { cin &gt;&gt; n &gt;&gt; m; s = pow(n*1.0, 2.0/3.0); // 适用于莫队的特殊分块大小 for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; chunk[i] = (i-1)/s+1; // 记录块号（也可以不记） } for (int i = 1; i &lt;= m; i++) { char op; int x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if (op == 'Q') { q[++qcnt] = pack1; } else { c[++ccnt] = pack2; } } sort(q+1, q+qcnt+1, cmp); int l, r, t; l = r = t = 0; for (int i = 1; i &lt;= qcnt; i++) { // 将三个维度移至指定位置 while (l &lt; q[i].l) del(a[l++]); while (l &gt; q[i].l) add(a[--l]); while (r &lt; q[i].r) add(a[++r]); while (r &gt; q[i].r) del(a[r--]); while (t &lt; q[i].t) timem(i, ++t); while (t &gt; q[i].t) timem(i, t--); ans[q[i].i] = tot; // 记录答案 } for (int i = 1; i &lt;= qcnt; i++) { cout &lt;&lt; ans[i] &lt;&lt; endl; } return 0;} Part 分块思想 End 矩阵部分咕一会… update: 2023/12/12 还没写。。。 update: 2024/01/01 还没写。。。","link":"/2023/07/17/%E5%88%86%E5%9D%97%E4%B8%8E%E7%9F%A9%E9%98%B5/"},{"title":"四边形不等式优化DP的证明","text":"〇. 前置知识 四边形不等式（几何意义上） 对于任意一个凸四边形（如图1），四个顶点分别为 $A,B,C,D$ ，其对角线交于点 $O$ ，则有 $AD+BC&gt;AB+CD$ 以及 $AD+BC&gt;AC+BD$ . 证明： $\\because AO+BO&gt;AB\\text{ and }CO+DO&gt;CD$ （三角形两边长之和大于第三边） $\\therefore (AO+DO)+(BO+CO)&gt;AB+CD$ （联立两不等式） $\\therefore AD+BC&gt;AB+CD$ （同理可得 $AD+BC&gt;AC+BD$） 四边形不等式（DP意义上） 这边主要都是些定义，因此不会有什么 针对定义的证明 。 定义1 设 $w$ 是定义在整数集合上的二元函数，对于任意整数 $i \\leq i’ \\leq j \\leq j’$ ，若有 $w(i,j)+w(i’,j’) \\leq w(i,j’)+w(i’,j)$ ，则称 $w$ 满足四边形不等式.[^1] 什么叫做定义在“整数集合上的二元函数”？就是 $w$ 函数有两个参数，它的值和参数均为整数. 但是，这似乎跟四边形没有半点关系吧.我们不如形象一点，对于刚才的定义，我们将 $i,i’,j,j’$ 表示在一个不太严谨的数轴上，这个数轴上 $a,b$ 两点的距离是 $w(a,b)$，然后，将中间的两个点，也就是 $i’$ 和 $j$ 向上抬升一点（如图2），这个四边形（在 $i’=j$ 的情况下是三角形）就出来了. 定义2 这是 定义1 的特殊情况。 对于任意整数 $i &lt; i+1 \\leq j &lt; j+1$ ，若有 $w(i,j)+w(i+1,j+1) \\leq w(i,j+1)+w(i+1,j)$ ，则称 $w$ 满足四边形不等式.[^1] 没啥好说的。。。 单调性 设 $w$ 是定义在整数集合上的二元函数，对于任意整数 $i \\leq i’ \\leq j \\leq j’$ ，若有 $w(i,j’) \\geq w(i’,j)$ ，则称 $w$ 具有单调性.[^1] 一. 证明四边形不等式定理 四边形不等式定理 如果 $w(i,j)$ 满足四边形不等式和单调性，则使用动态规划计算 $f$ 数组的时间复杂度为 $\\Theta(n^2)$ . 引理1 1 二. 引用[^1]: 参考 罗勇军的博客——算法竞赛专题解析（10）：DP优化(1)–四边形不等式 [^2]:F. Frances Yao原论文","link":"/2023/11/18/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96DP%E7%9A%84%E8%AF%81%E6%98%8E/"},{"title":"技巧合集","text":"Lambda表达式首先，Lambda读作 [‘læmdə]。 好，接下来我们步入正题。就我个人认为，Lambda表达式是一种能让一些不会经常调用的 简单函数 写得更简单的方法，其中最典型的例子就是sort自定义排序函数。假设我们有一个结构体node如下： 123struct node{ int x, y;}points[114514]; 一般来说，我们会写一个cmp函数如下： 1234bool cmp(node &amp;a, node &amp;b) { if (a.x == b.x) return a.y &lt; b.y; return a.x &lt; b.x;} 或者更高级一点，使用operator重载运算符： 1234567struct node{ int x, y; const bool operator&lt;(const node &amp;b) const { if (x == b.x) return y &lt; b.y; return x &lt; b.x; }}points[114514]; 但是，这些写法都是需要额外再开一个函数的，并且对于先按某规则排序再按另一种规则排序这种情况的处理并不好（第二种写法甚至不能在这种情况下使用）。于是我们需要一种更简单的方法来写排序函数——Lambda表达式。先看效果，它写出来大概长这样： 1sort(points+1, points+n+1, [](node a, node b) -&gt; bool { return (a.x==b.x?a.y&lt;b.y:a.x&lt;b.x); }); * 还能再简单点吗？* 可以，那么就是这样：（下面代码中的-&gt; bool被省略了） 1sort(points+1, points+n+1, [](node a, node b) { return (a.x==b.x?a.y&lt;b.y:a.x&lt;b.x); }); 这只是其中一种使用方法。借此，我们还可以把局部变量当做“全局”变量来用（并不是真的全局，但是在Lambda表达式的函数内可以使用这些局部变量），具体实现方法是 捕获 （这东西我还没想到在OI中的应用），也就是在那个[]内部做文章，实现可以参考参考资料。 upd 20231130 除此之外，Lambda表达式还可以在函数内部定义函数，例如，我们可以在 main 函数里定义一个 add 函数用来给链式前向星加边： 12345678910111213struct node{ int nxt, to;}g[200010];int head[200010], tot;int main() { function&lt;void(int, int)&gt; add = [](int u, int v){ g[++tot] = {head[u], v}; head[u] = tot; }; add(1, 2); return 0;} 而这个函数也是受“变量”的定义域所影响的，例如下面在 test 函数中调用 add() 函数将出现 $\\text{CE}$ ： 1234567891011121314151617struct node{ int nxt, to;}g[200010];int head[200010], tot;void test() { add(1, 2);}int main() { function&lt;void(int, int)&gt; add = [](int u, int v){ g[++tot] = {head[u], v}; head[u] = tot; }; test(); return 0;} 不仅如此，我们甚至可以在这基础上写递归（以 Tarjan 为例）： 123456789101112131415161718192021222324252627282930313233343536373839struct node{ int nxt, to;}g[200010];int head[200010], tot;int dfn[200010], low[200010], cnt;int st[200010], top;bool inst[200010];int scc[200010], sc;int main() { function&lt;void(int)&gt; tarjan = [&amp;tarjan](int u) { dfn[u] = low[u] = ++cnt; st[++top] = u, inst[u] = 1; for (int i = head[u]; i; i = g[i].nxt) { int v = g[i].to; if (!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else if (inst[v]) { low[u] = min(low[u], dfn[v]); } } if (dfn[u] == low[u]) { sc++; while (st[top] != u) { scc[st[top]] = sc; inst[st[top]] = 0; top--; } scc[st[top]] = sc; inst[st[top]] = 0; top--; } return ; }; return 0;} 其主要就是一个 function 的实现，语法是 function&lt;返回值类型(参数类型1, 参数类型2, ...)&gt; = [捕获](传参){函数主体} ，而要递归就只用在捕获处引用这个函数（就像上面的例子）。 auto (C++11新语法)先说怎么启用C++11或其他新版本，对于Dev-C++，在编译选项中的“在编译时添加这些参数”添加-std=c++11，这里的 11 可以换为其他版本如：-std=c++23。auto 可以自动匹配变量类型，但是没多大用（除非使用迭代器iterator这种难写的类型），具体而言可以这么写： 12auto i = 1ll;auto j = mp.begin(); // mp是一个map&lt;int, int&gt; (值得一提的是，使用迭代器遍历map遍历出来的是pair类型的东西)并且，auto还有一些可以减少代码量的用法，例如遍历vector: 1234567for (int i = 0; i &lt; (int)vec.size(); i++) { cout &lt;&lt; vec[i] &lt;&lt; endl;}// 等价于for (auto &amp;i : vec) { cout &lt;&lt; i &lt;&lt; endl;} 同理，其他能使用迭代器的容器都可以如此遍历（但是，栈和队列都不行）。 using这个语法很简单，应用只有一个——using ll = long long 。它能定义 ll 为 long long 并且还不能批量替换 int 。如果要把代码中所有 int 替换为 long long，请使用 #define int long long （虽然这是未定义行为）. 模块化思想 与 类和对象将代码中实现不同功能的代码封装成函数，这会对 debug 有极大的帮助。对象嘛，不是你想的那个对象，你可以使用 namespace 或 class。给个例子： 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;namespace work1{ string main(string t) { return t+t+&quot;adwe&quot;; } void print(string t) { cout &lt;&lt; main(t) &lt;&lt; endl; }};class work2{private: string main(string t) { return t+t+&quot;adwe&quot;; }public: void print(string t) { cout &lt;&lt; main(t) &lt;&lt; endl; }};int main() { // 使用namespace的方法 work1::print(&quot;1abc&quot;); cout &lt;&lt; work1::main(&quot;2abc&quot;) &lt;&lt; endl; // 使用class的方法 work2 *p = new work2; // 新建一个类 p-&gt;print(&quot;3abc&quot;); p-&gt;main(&quot;4abc&quot;); // 无法编译} 调试常用离线比赛常用：cerr因为离线比赛中需要进行文件输入输出，但是每次开关文件很麻烦，而 cerr 可以不受文件输入输出流影响，往标准输入输出流里进行输出，但代价是每次输出都会清理一遍缓冲区，时间消耗极大，所以调试完后一定一定要把所有 cerr 语句删除。 啥都能用的 assert位于头文件 cassert 中，如果不用万能头要把头文件导入。 在代码中可以写 assert(a &lt;= n &amp;&amp; 1 &lt;= a); 来判断 a 是否在给定的范围内，如果不在程序将立即终止运行并输出错误所在的行号等信息，准确来说，只要 assert 语句中的表达式的值为 false ，就会返回报错。 可以使用宏 #define NDEBUG 即可一次性禁用所有 assert 语句。 值得注意的是，在洛谷中，如果 assert 返回报错会显示 RE ，并返回错误信息： 12Runtime Error.Received signal 6: Aborted / IOT trap. 参考资料Lambda表达式 官方文档 zhihu","link":"/2023/07/19/%E6%8A%80%E5%B7%A7%E5%90%88%E9%9B%86/"},{"title":"图论基础","text":"存图邻接矩阵实现： 12345678int g[N][N];g[u][v] = w;for (int v = 1; v &lt;= N; v++) { if (!g[u][v]) continue; // ...} 空间复杂度：$O(n^2)$ 优点 配合Floyd算法，效果嘎嘎好 支持随机访问，即直接查询某条边是否存在 代码好写 缺点 空间复杂度太高，是个硬伤 邻接表实现： 12345678vector&lt;pair&lt;int, int&gt;&gt; g[N];g[u].push_back({v, w});for (pair&lt;int,int&gt; i : g[u]) { int v = i.first, w = i.second; // ...} 空间复杂度：$O(m)$ 优点 空间复杂度小 同一个点空间连续，有效降低Memory Cache带来的时间花销 写循环遍历 $u$ 边时可以少写点代码：for (pair&lt;int,int&gt; i : g[u]) 缺点 由于 vector ，空间复杂度要翻个倍，在卡空间的题目中它不是好选择 莫名其妙TLE（STL造成的） 链式前向星实现： 1234567891011121314struct node{ int to, nxt, w;}g[M];int head[N], cnt;void add(int u, int v, int w) { g[++cnt] = {v, head[u], w}; head[u] = cnt;}for (int i = head[u]; i; i = g[i].nxt) { int v = g[i].to, w = g[i].w; // ...} 空间复杂度：$O(m)$ 优点 空间复杂度真的小，没有 vector 的两倍空间限制 缺点 Memory Cache耗时极高，尤其是完全图","link":"/2023/12/28/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/"},{"title":"最短路基础","text":"前置知识：图论基础 Floyd算法用于求解任意两点的最短路。","link":"/2024/01/01/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%9F%BA%E7%A1%80/"},{"title":"期末总结","text":"知识总结就不放在这里了，往回走走就能看到的。 这学期的一些问题论：如何打击自己的自信 平时练习做题时没法深入思考，也不知道如何提升这方面的能力；思路很跳跃，虽然不排除正好跳到正解的可能性，但是就是没法深入；又感觉自己有点急于求成，高估自己进步的速度了。 而且仔细回想一下，发现整个作业表的题并不是自己推着在走（倒也不是完全都是，不是的很少）而是自己在被拖着走，有的题目没来得及思考就讲评了。在讲评前过的题也有很大部分是和同学讨论过的。说绝对点就叫不会独立思考，再说深入点：懒得思考。 考试时考试的时候没有策略。有时对着一道题死磕好久然后发现思路从一开始就不正确而白白浪费几个小时，有时对着一道题看了一会有点思路又深入不进去导致最后惊奇地发现自己和正解的思路只有一道红题的距离。即使有了思路，代码实现也是各种粗心的问题都会犯，见区间DP总结T2。感觉代码力也要不行了。。。 而且这里有几个我认为重大的问题： 破题的能力很有问题，比如这次考试的T1，我就认为它是纯纯的基础的有规律的构造，完全没往搜索那个方面想，这也和我在思考是做的数据不够大有关。也许这和我的练习情况有关，就是练少了，见过的题太少，但是就是这样我也没有办法去针对性的练习。 而且思考时很少用纸笔去思考，大部分时间大脑都是在空转。 拿到一道题不知道从哪里下手 ，于是干脆不下手 也不会去尝试，妄图一步到位直接AC，忽略了部分分及其的作用。例如有一些看起来不正确的搜索（时间复杂度无法证明/说明）就直接不去写。 “正解”写出来之后也基本不会去对拍或是写个SPJ，最多写个很水很水的hack。最后是所谓的正解只得了60分甚至爆零（区间DP总结T2还是个很好的例子）。 考试时很难有信心，导致出成绩时心态死活调整不过来，形成恶性循环。 讲评时这学期听MikeZ讲题下来，会在讲题时做一些笔记了，但是讲完后仍然很难从笔记中整理出一条完整的的思路，就是说笔记没法连起来，是散的。这导致什么呢？以后来复习的时候根本看不懂。（笑 发现MikeZ讲题时总会在题目讲完之后想到一些拓展，假如这个问题是个计数问题呢？假如要求字典序最小的方案呢？做题AC的时候多像MikeZ这样问问自己总会有点好处的。 理下来感觉自己一无是处了。 没有几天就是第二次选拔了，希望我能抓紧这最后的几天时间把一些没搞懂的知识再搞懂，大力复习，在即将到来的这一场考试中好好发挥，考出一个理想的成绩！ヾ(≧▽≦*)o","link":"/2024/01/13/%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/"},{"title":"最短路技巧","text":"前置知识：图论基础，最短路基础 Super Root 超级源点、加点、加边特征 需要添加边，但是暴力加边时间or空间复杂度不可取； 加边是针对某一类点加边； 答案最终会汇集到一个点上，一些网络流的题需要建立超级源点和超级汇点。 注意点 加边时考虑边权设计； 如果要对超级源点加双向边，要考虑周全一些不合法的情况，例如会不会无边权超级传送； 加点要算好空间，算好下标。 例题 给定一棵树，$1$ 为根节点，对于树上每条边 $(u, v)$ 都具有一个权值 $w$ 。但是，如果两个节点的高度差为 $k$ ，则可以通过 $p$ 的权值直接到达，求在这棵树上从 $s$ 到 $t$ 的最短路径长度。多组测试数据。$1 \\le T \\le 5$$2 \\le n \\le 10^6$$1 \\le u_i,v_i,s,t \\le n, u_i \\neq v_i, s \\neq t$$1 \\le w_i,k \\le 10^6$$0 \\le p \\le 10^6$ 我们发现这道题需要加边跑最短路，然而，$\\text{Dijkstra}$ 带上加边会跑到 $O((n+m+n^3)\\log (m+n^3)+n^3)$ ，这里极限数据的情况是整棵树有 $\\sqrt n$ 层，每层有 $\\sqrt n$ 个点，且 $k = 1$ 。即使我们不真正连边，仍然还有 $O((n+m+n^3)\\log (m+n^3))$ 的时间复杂度。死得透透的。 因此我们考虑对每一层建立一个超级源点，边权为 $0$ ，再对上下 $k$ 层的超级源点连边，因为这个点既可以上又可以下，所以要连双向边。然鹅，这个方案有一个巨大的问题。 如果我们连双向边，那么最短路会借助超级源点在同一层实现 $0$ 权值跳转，很明显，这是不合法的。于是我们考虑每层加两个超级源点，一个用于向外走，一个向内走，问题就解决了，时间复杂度 $O((5n+m)\\log (2n+m))$ 。 给出一个图，每次只能连续走两条边，其权值为两条边权值的和的平方，求以 $1$ 为源点时分别到 $1\\sim n$ 的最短路。$2 \\leqslant n \\leqslant 10^5,1 \\leqslant m\\leqslant min(\\frac{n(n-1)}{2},2*10^5)$$1\\leqslant v_i,u_i \\leqslant n,1 \\leqslant w_i \\leqslant50,u_i\\neq v_i$ 同时处理两条边是有些困难的。考虑往图里增加信息。我们发现边权十分小，只有 $50$ 。于是我们想到建分层图，入边 $(u,v,w)$ 即建一条边从第 $w$ 层图 $v$ 点到原图 $v$ 点，出边 $(u,v,w)$ 就是建一条边从原图 $v$ 点到第 $w$ 层图 $v$ 点。这样做正确性显然。 2. 最短路计数这里要提两个概念 附录SPFA玄学优化据某位不知名人士所言，SPFA的时间复杂度可以用 $O(m+n\\log n)$ 来拟合，而Dijkstra的时间复杂度为 $O(m\\log n)$ 。这意味着如果题目不卡SPFA，则SPFA跑得比Dijkstra还要快。如果卡SPFA，还可以通过SLF、mcfx等优化方法来使SPFA更快。甚至专门卡SPFA的标准版单源最短路径的次优解（$\\text{80ms}$）就是使用了SLF-swap优化过的。","link":"/2024/01/01/%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%8A%80%E5%B7%A7/"},{"title":"欧拉反演","text":"果果要求掌握的东西当然是要掌握的咯。 最终形式$$\\Large{n=\\sum_{d|n}^{}}{\\varphi(d)}$$ 证明$$\\large\\because n=\\sum_{d|n}\\sum_{j=1}^{n}{[\\gcd(j,n)=d]}$$ 解释一下，首先，这里的 $\\gcd(j,n)$ 一定是只有一个值，不可能说有两个不同的值来自同一个 $\\gcd(j,n)$ ；其次，为什么这一坨东西等于 $n$ 呢，因为其一说的每个 $\\gcd$ 都有唯一确定的值，因此我们只需要枚举 $\\gcd$ 的每种可能并枚举所有 $n$ 以内的正整数就必然有且仅有一种可能的 $d$ 满足每组 $\\gcd(j,n)=d$ 。 换句话说，因为一个 $\\gcd(j,n)$ 只对应唯一一个 $d$ ，这里我们把所有可能的 $\\gcd$ 的值和所有的 j 都枚举了自然其值也就等于 $n$ 了（主要就是说明一个不重也不漏）。 $$\\large\\therefore \\ n=\\sum_{d|n}\\sum_{j=1}^{\\frac{n}{d}}{[\\gcd(j,\\frac{n}{d})=1]}$$ 这里没什么好说的，目的是把 $\\gcd$ 的值化为 $1$ 后能转化成欧拉函数的形式。 $$\\large\\therefore n=\\sum_{d|n}{\\varphi(\\frac{n}{d})}$$ $$\\large\\therefore n=\\sum_{d|n}{\\varphi(d)}$$ 这里是因为每个 $\\frac{n}{d}$ 和 $d$ 是对应的，所以能如此转化。 例题 多组数据，每组数据给出一个数 $n$ ，求 $\\sum_{i=1}^{n}{\\gcd(i,n)}$ 。 利用欧拉反演，改变题目公式如下： $$\\sum_{i=1}^{n}{\\sum_{d|\\gcd(i,n)}{\\varphi(d)}}$$ 拆开 $\\gcd$ 得： $$\\sum_{i=1}^{n}{\\sum_{d|i,d|n}{\\varphi(d)}}$$ 改变循环顺序得： $$\\sum_{d|n}\\varphi(d)\\sum_{i=1}^{n}[d|i]$$ 化简得： $$\\sum_{d|n}\\varphi(d)\\frac{n}{d}$$ 关于推导式子就没了。这时只需将 $\\text{phi}$ 预处理，每次询问 $\\sqrt{n}$ 复杂度。 CF1900D Small GCD 先排序，可得以下原公式： $$\\sum_{i=1}^{n}\\sum_{j=1}^{i-1}\\gcd(a_i,a_j)(n-i)$$ 带入欧拉反演如下： $$\\sum_{i=1}^{n}\\sum_{j=1}^{i-1}(\\sum_{d|\\gcd(a_i,a_j)}{\\varphi(d)})(n-i)$$ 化简： $$\\sum_{i=1}^{n}(n-i)\\sum_{j=1}^{i-1}\\sum_{d|a_i,d|a_j}{\\varphi(d)}$$ $$\\sum_{i=1}^{n}(n-i)\\sum_{d|a_i}\\varphi(d)\\sum_{j=1}^{i-1}[d|a_j]$$ $$\\sum_{i=1}^{n}(n-i)\\sum_{d|a_i}\\varphi(d)\\cdot cnt_{d}$$ 其中我们可以边枚举 $i$ 边处理 $cnt_d$ ，并预处理 $\\varphi(x)$ 。因此总时间复杂度为 $O(M+TN\\sqrt{M})$ ，$M$ 表示 $a_i$ 的值域，还会有一些小常数，会有点卡常。 果果要求掌握的东西当然是要掌握的咯。 最终形式$$\\Large{n=\\sum_{d|n}^{}}{\\varphi(d)}$$ 证明 $$\\large\\because n=\\sum_{d|n}\\sum_{j=1}^{n}{[\\gcd(j,n)=d]}$$ 解释一下，首先，这里的 $\\gcd(j,n)$ 一定是只有一个值，不可能说有两个不同的值来自同一个 $\\gcd(j,n)$ ；其次，为什么这一坨东西等于 $n$ 呢，因为其一说的每个 $\\gcd$ 都有唯一确定的值，因此我们只需要枚举 $\\gcd$ 的每种可能并枚举所有 $n$ 以内的正整数就必然有且仅有一种可能的 $d$ 满足每组 $\\gcd(j,n)=d$ 。 换句话说，因为一个 $\\gcd(j,n)$ 只对应唯一一个 $d$ ，这里我们把所有可能的 $\\gcd$ 的值和所有的 $j$ 都枚举了自然其值也就等于 $n$ 了（主要就是说明一个不重也不漏）。 $$\\large\\therefore \\ n=\\sum_{d|n}\\sum_{j=1}^{\\frac{n}{d}}{[\\gcd(j,\\frac{n}{d})=1]}$$ 这里没什么好说的，目的是把 $\\gcd$ 的值化为 $1$ 后能转化成欧拉函数的形式。 $$\\large\\therefore n=\\sum_{d|n}{\\varphi(\\frac{n}{d})}$$ $$\\large\\therefore n=\\sum_{d|n}{\\varphi(d)}$$ 这里是因为每个 $\\frac{n}{d}$ 和 $d$ 是对应的，所以能如此转化。 例题 多组数据，每组数据给出一个数 $n$ ，求 $\\sum_{i=1}^{n}{\\gcd(i,n)}$ 。 利用欧拉反演，改变题目公式如下： $$\\sum_{i=1}^{n}{\\sum_{d|\\gcd(i,n)}{\\varphi(d)}}$$ 拆开 $\\gcd$ 得： $$\\sum_{i=1}^{n}{\\sum_{d|i,d|n}{\\varphi(d)}}$$ 改变循环顺序得： $$\\sum_{d|n}\\varphi(d)\\sum_{i=1}^{n}[d|i]$$ 化简得： $$\\sum_{d|n}\\varphi(d)\\frac{n}{d}$$ 关于推导式子就没了。这时只需将 $\\text{phi}$ 预处理，每次询问 $\\sqrt{n}$ 复杂度。 CF1900D Small GCD 先排序，可得以下原公式： $$\\sum_{i=1}^{n}\\sum_{j=1}^{i-1}\\gcd(a_i,a_j)(n-i)$$ 带入欧拉反演如下： $$\\sum_{i=1}^{n}\\sum_{j=1}^{i-1}(\\sum_{d|\\gcd(a_i,a_j)}{\\varphi(d)})(n-i)$$ 化简： $$\\sum_{i=1}^{n}(n-i)\\sum_{j=1}^{i-1}\\sum_{d|a_i,d|a_j}{\\varphi(d)}$$ $$\\sum_{i=1}^{n}(n-i)\\sum_{d|a_i}\\varphi(d)\\sum_{j=1}^{i-1}[d|a_j]$$ $$\\sum_{i=1}^{n}(n-i)\\sum_{d|a_i}\\varphi(d)\\cdot cnt_{d}$$ 其中我们可以边枚举 $i$ 边处理 $cnt_d$ ，并预处理 $\\varphi(x)$ 。因此总时间复杂度为 $O(M+TN\\sqrt{M})$ ，$M$ 表示 $a_i$ 的值域，还会有一些小常数，会有点卡常。","link":"/2023/11/27/%E6%AC%A7%E6%8B%89%E5%8F%8D%E6%BC%94/"},{"title":"近期资料","text":"四边形不等式 证明1+例题（在文末） 证明2 证明3 区间dp 区间dp的几大模型 【没用】筛选器 常用网站 Martdown编辑器——StackEdit Latex编辑器——Overleaf 【没用】神奇语言Hackell入门 【没用】闲逛时发现的数据结构——猫树","link":"/2023/12/28/%E7%9B%AE%E5%BD%95/"},{"title":"组合数与乘法逆元","text":"组合数众所周知，组合数有两种求法。 杨辉三角求法：$\\dbinom{i}{j}=\\dbinom{i-1}{j}+\\dbinom{i-1}{j-1}$ 定义法：$\\dbinom{i}{j}=\\Large\\frac{n!}{m!(n-m)!}$ 其中，杨辉三角的空间占用很大，所以除非数据量较小（如：$N\\leqslant 10^{4}$）的情况，我们不会使用这种求法，但是这种求法可以实现 $O(1)$ 查询，因此它也适用于需要大量查询的题目。而定义法适用于不需要大量查询（至少没有杨辉三角的情况多）的题目，但是因为有阶乘的存在，使得实现 $O(1)$ 还需要一点点数学上的优化，并且，其适用的数据范围（$N\\leqslant 10^5$）一般都需要 $\\text{mod}$ 一个极大数（阶乘不 $\\text{mod}$ 留着爆 $\\text{long long}$ 吗），然而我们都知道，同余的性质不适用于除法，这导致我们处于一个进退两难的地步。古语有云：$\\text{To modulo or not to do, it’s a question.}$这时候，我们就需要乘法逆元来帮忙了。 乘法逆元按照惯例，先说定义：如果一个线性同余方程 $ax\\equiv 1(\\mathrm{mod}\\;b)$ ，则称 $x$ 为 $a\\;\\mathrm{mod}\\;b$ 的逆元，记为 $a^{-1}$ 。我们可以把它理解成倒数，一种在模 $p$ 意义下的倒数。因此，我们可以知道一个数逆元的逆元就是这个数本身。逆元的求法有两种： Extend-GCD 拓展欧几里得法就是直接解上述定义中的方程，没什么好说的。 123456789void exgcd(int a, int b, int &amp;x, int &amp;y) { if (b == 0) { x = 1, y = 0; return ; } exgcd(b, a%b, x, y); y -= a/b*x; return ;} 快速幂法$\\huge 使用这玩意的前提是\\;b\\;为质数！$ 证明： $\\because ax\\equiv 1(\\mathrm{mod}\\;b)$由费马小定理: $a^{p-1}\\equiv1(\\mathrm{mod}\\;b)$得 $ax\\equiv a^{p-1}(\\mathrm{mod}\\;b)$$\\therefore x\\equiv a^{p-2}(\\mathrm{mod}\\;b)$ 所以我们可以直接写一个快速幂板板！ 12345678910int power(int a, int b) { b -= 2; int ans = 1; while (b) { if (b&amp;1) ans = ans*a%p; a = a*a%p; b &gt;&gt;= 1; } return ans;} 除此之外，我们还可以使用线性递推求一大串数的逆元（但是我不会推）。 $i^{-1}\\equiv\\begin{cases}1&amp;\\mathrm{if}\\;i=1\\-\\left\\lfloor\\dfrac{p}{i}\\right\\rfloor (p\\;\\mathrm{mod}\\;i)^{-1}&amp;\\mathrm{otherwise.}\\end{cases}\\;(\\mathrm{mod}\\;p)$ 那么，归根结底，我们到底如何使用乘法逆元加速定义法的组合数呢？ 乘法逆元优化组合数我们不能使用定义法求带模组合数是因为除法不具备同余的性质，但是，我们可以用逆元将除法转化为乘法，进而求出组合数。那么，原来的定义法公式可以转化为 $\\dbinom{i}{j}=\\large n!\\times inv[m] \\times inv[n-m]$（还是说可以把逆元理解为倒数）首先，$n!$ 是可以预处理出来的，而 $inv[i]$ 使用上面说的两种方式很明显会 $TLE$ (但事实上并不会) ，剩下的只有一条路了——递推。首先，我们还是可以使用上面说到的递推公式，但是对于阶乘，我们还有另一个递推公式：$$inv[i!]=inv[(i+1)!]\\times (i+1)$$怎么理解呢？还记得我们说过，逆元就是一种倒数吗？借此，有如下公式：$$ \\frac{1}{i!}=\\frac{1}{(i+1)!}\\times (i+1) $$答案已经呼之欲出了！","link":"/2023/07/19/%E7%BB%84%E5%90%88%E6%95%B0%E4%B8%8E%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"},{"title":"背包问题","text":"Ⅰ. 基础模型A. 01背包即每个物品要么选，要么不选。我们可以设状态 $f_{i,j}$ 表示考虑前 $i$ 个物品总体积 $\\leq j$ 的最大价值，于是状态转移如下： $$f_{i,j}=\\max(f_{i-1,j},f_{i-1,j-w_i}+v_i)$$ 前一个表示不选第 $i$ 个物品的情况，后一个表示选第 $i$ 个物品的情况。 初始化：$f_{i,j}=0$ 。 考虑怎么统计方案数。状态定义一样，但是表示的是方案数，于是又有转移方程如下： $$f_{i,j}=f_{i-1,j}+f_{i-1,j-w_i}$$ 初始化：$f_{i,0}=f_{0,j}=1$ 。 考虑优化空间，我们发现，每次转移只会用到上一维的状态，于是就可以把DP数组压成一维。代码如下： 12345for (int i = 1; i &lt;= n; i++) { for (int j = m; j &gt;= w[i]; j--) { f[j] = max(f[j], f[j-w[i]]+v[i]); }} B. 完全背包就是在01背包的基础上每个物品可以选任意多个。状态设计同01背包，转移如下： $$f_{i,j}=\\max(f_{i-1,j},f_{i,j-w_i}+v_i)$$ 区别在哪里呢？完全背包可以从当前的 $i$ 的状态转移过来，因为一个物品可以一选再选。 初始化、变形成方案数统计和压空间和上面的01背包大同小异，不过多赘述。贴个优化空间代码： 12345for (int i = 1; i &lt;= n; i++) { for (int j = w[i]; j &lt;= m; j++) { f[j] = max(f[j], f[j-w[i]]+v[i]); }} C. 多重背包","link":"/2023/12/28/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"title":"题解：Fence Loops","text":"更好的阅读体验 这道题难点在于建图，建完图之后用 $\\text{Dijkstra}$ 或 $\\text{Floyd}$ 跑个最小环就行了。 我的建图方法和其他题解所赘述的有所不同（在同机房dalao的指点下想到的）。 建图我们将题目中读入的边看做点，题目中的边权在这里就是点权，考虑边权的设计。不难发现，当篱笆可以组成环时，将两个点间的边权定义为其点权之和，那么环的权值就是所有边权之和的 $\\frac{1}{2}$ （因为每个点权都被加了两次）。 最小环我用的是 $\\text{Dijkstra}$ 跑最小环。大致流程如下： 枚举一条边 $(u,v)$ 并删除； 从这条边的一个端点 $u$ 开始跑 $\\text{Dijkstra}$ 到另一个端点 $v$ ，可以获得一个值 $dis_v$ 表示不经过 $(u,v)$ 时两点的最短路； 最后统计全局最小环为 $ans=\\min(w(u,v)+dis_v)$ 。在本题中最终答案为 $ans\\times\\frac{1}{2}$ 。 正确性显然。 一个小问题有细心的读者会发现，如果我们将边转化成点，会出现一个问题： 按上文的找最小环的方法会找到三条边都交于一点的“环”，这样的答案是不合法的，因此我们要规定找最小环时，必须是从一边入另一边出。可以通过开一个 $flg_{u,v}$ 表示 $u$ 这个点，通往 $v$ 的边是在原图的哪一边。 但是由于我们读入时没有处理，即我们不知道谁的左边是谁的右边，因此在判断时要统一一个公共点来判断，于是在跑 $\\text{Dijkstra}$ 时处理一个 $f$ 表示上一个点。具体实现间代码。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;int n;int g[101][101];bool flg[101][101];struct node{ int dis, u, f; bool operator&lt;(const node&amp; b) const { return dis &gt; b.dis; }};priority_queue&lt;node&gt; q;int dis[101];bool vis[101];int s, t;bool dijkstra() { memset(dis, 0x3f, sizeof dis); memset(vis, 0, sizeof vis); dis[s] = 0; q.push({0, s, 0}); while (!q.empty()) { int u = q.top().u, f = q.top().f; q.pop(); if (vis[u]) continue; vis[u] = 1; for (int v = 1; v &lt;= n; v++) { if (!g[u][v]) continue; if (u == s &amp;&amp; v == t) continue; if (u == t &amp;&amp; v == s) continue; if (u != s &amp;&amp; flg[u][f] == flg[u][v]) continue; if (dis[v] &gt; dis[u]+g[u][v]) { dis[v] = dis[u]+g[u][v]; q.push({dis[v], v, u}); } } } return dis[t]!=0x3f3f3f3f;}int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { int k, v, n1s, n2s, x; cin &gt;&gt; k &gt;&gt; v &gt;&gt; n1s &gt;&gt; n2s; for (int i = 1; i &lt;= n1s; i++) { cin &gt;&gt; x; g[k][x] += v, g[x][k] += v; flg[k][x] = 0; } for (int i = 1; i &lt;= n2s; i++) { cin &gt;&gt; x; g[k][x] += v, g[x][k] += v; flg[k][x] = 1; } } int ans = 0x3f3f3f3f; for (s = 1; s &lt;= n; s++) { for (t = s+1; t &lt;= n; t++) { if (!g[s][t]) continue; if (dijkstra()) { ans = min(ans, (g[s][t]+dis[t])/2); } } } cout &lt;&lt; ans;}","link":"/2023/12/17/%E9%A2%98%E8%A7%A3%EF%BC%9AFence%20Loops/"},{"title":"题解：Sending a Sequence Over the Network","text":"更好的阅读体验 本蒟蒻的第一篇题解。 这道题我看大家都是用一维 DP 做的，本蒟蒻今天在考场上写了种二维 DP 的做法。我个人认为这种可能理解起来会简单一些（虽说写起来麻烦了点），于是就有了这篇题解。 思路当时（考场上）想了半天没想出来怎么使用一维 DP 解决这道题，便想了一种二维 DP 的做法。 我们定义 $f[0][i]$ 表示以 $i$ 作为一段的头部时是否可行，$f[1][i]$ 表示以 $i$ 作为一段的结尾是否可行。并且在原序列中添加两个点：$0$ 和 $n+1$。 状态转移（以下 $i$ 均指当前考虑的位置）： 头的转移 如果上一个位置可以作为尾，那么这个位置就可以作为头。也就是 $f[0][i] = f[1][i-1]$ 如果当前位置作为头，那么下一段的头的位置也可以作为头。也就是 $f[0][i+a[i]+1] = f[0][i]$ 尾的转移 如果上一段的尾的位置可以做尾，则当前位置可以做尾。也就是 $f[1][i] = f[1][i-a[i]-1]$ 如果这一段的头的位置可以做头，那么当前位置也可以做尾。也就是 $f[1][i]=f[0][i-a[i]]$ 注意：写代码的时候要注意下标不能越界。 根据以上的转移（可能有点乱），我们能知道初始状态为：$$f[1][0] = f[0][1] = 1$$ 而最后我们只需要判断第 $n$ 个位置能否做尾或第 $n+1$ 个位置能否做头就好。 代码（供群众批判） 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int n;int a[200010];bool f[2][200010];/* 0: 作为头 1: 作为尾 */int main() { int T; cin &gt;&gt; T; while (T--) { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; memset(f, 0, sizeof f); // 多测不清空，爆零两行泪 f[1][0] = 1; f[0][1] = 1; for (int i = 1; i &lt;= n; i++) { // i作为头 // 从上一个是尾转移 f[0][i] |= f[1][i-1]; // 隐藏情况：之前有人帮它更新了 // 更新下一个可能作为头的 if (f[0][i] &amp;&amp; i+a[i]+1 &lt;= n+1) f[0][i+a[i]+1] = 1; // i作为尾 if (i-a[i]-1 &gt;= 0) f[1][i] |= f[1][i-a[i]-1]; if (i-a[i] &gt;= 0) f[1][i] |= f[0][i-a[i]]; } if (f[1][n] || f[0][n+1]) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; }}","link":"/2023/07/20/%E9%A2%98%E8%A7%A3%EF%BC%9ASending%20a%20Sequence%20Over%20the%20Network/"},{"title":"题解：速战速决","text":"进入博客食用更香！ 一道贪心题。 无解很明显的，当 $n=1$ 时，因为小I先手，小J可以直接收牌，所以小I无法获胜。 策略Case 1 小 I 手上没有任何能配对的牌也就是说对于每一对牌总有一张在小I的手上。 此时我们应该先打出对面出牌序列中最后一张牌，随后对面出什么牌我们就跟着出什么牌，确保小J出的牌能被我们立刻收掉。 最后对面出他的最后一张牌把我们出的第一张牌收掉，此时我们手上的牌全是成对的，对方只有一对牌。随便出一张手上的牌把对面的一张牌收掉，对面下次出牌就必输。 Case 2 小 I 贪心每一回合此时我们手中必有一对牌。我们能用这对牌来干嘛呢？一开始我们埋下这张牌作为保险，如果后面对面想收牌（牌堆里的或是我手上的），我们就打出这对牌的另一张把整个牌堆清空。 我们可以像 $\\text{Case 1}$ 一样，对面出牌我们紧跟着收牌 ，考虑以下几种情况（以下 $A_i$ 指我们出的编号为 $i$ 的牌，$B_i$ 指对面出的编号为 $i$ 的牌，$[\\cdot\\cdot\\cdot]$ 表示当前时刻之后的假设情况）： $A_?…B_i[…A_i]$ 以及 $A_?…B_i[…B_i]$ 这两种情况都会对我们的策略造成威胁，因此在这个时候应该立即收掉所有牌。 $A_i…A_iB_j[…]$ 这种情况会使我们误收场上所有牌，导致对方出的 $B_j$ 要么收不掉（这意味着我们要花额外的步数去收这张牌）或是对面会在后面某一时刻清场（这意味着我们要么输，要么步数更多）。 其余情况按正常的成对出牌。 基于以上几点对方就不能在任何时刻收牌，因为我们要么快人一步把前面的收了要么把他出的第一张牌直接收了，而此时也会达到步数最小值，不难发现这个步数最小值是 $n$ 。 * 蒟蒻个人理解，可能有些问题欢迎大家指出！ 码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 300010;int n;int s[2*MAXN], top, cnts[MAXN];int mine[MAXN];int a[MAXN];queue&lt;int&gt; q;void pop(int x) { // 清理公共牌堆 while (s[top] != x) { cnts[s[top]]--; mine[s[top]]++; q.push(s[top]); top--; } cnts[s[top]]--; mine[s[top]]++; q.push(s[top]); top--;}void push(int x) { // 打牌 s[++top] = x; cnts[x]++;}int main() { scanf(&quot;%d&quot;, &amp;n); if (n == 1) return printf(&quot;-1&quot;)&amp;0; // 无解 for (int i = 1; i &lt;= n; i++) { mine[i] = 2; } int st = -1; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, a+i); mine[a[i]]--; } for (int i = 1; i &lt;= n &amp;&amp; st == -1; i++) if (mine[i] == 2) st = i; for (int i = 1; i &lt;= n; i++) { for (int j = mine[i]-(i==st); j &gt;= 1; j--) q.push(i); } if (st == -1) { // 没有成对的牌 printf(&quot;%d\\n%d&quot;, n+2, a[n]); for (int i = 1; i &lt; n; i++) printf(&quot; %d&quot;, a[i]); printf(&quot; %d %d&quot;, a[1], a[1]); return 0; } printf(&quot;%d\\n%d&quot;, n, st); mine[st]--; push(st); push(a[1]); for (int i = 2; i &lt;= n; i++) { int x = a[i]; if (mine[x] || cnts[x]) { // 有威胁。清空牌堆 printf(&quot; %d&quot;, s[1]); pop(s[1]); } else { if (q.front() == s[1]) { // 会误收牌堆 q.push(q.front()); // 将队首移到队尾 q.pop(); } int nxt = q.front(); printf(&quot; %d&quot;, nxt); if (cnts[nxt]) { pop(nxt); } else { push(nxt); mine[nxt]--; q.pop(); } } push(x); }}","link":"/2023/12/11/%E9%A2%98%E8%A7%A3%EF%BC%9A%E9%80%9F%E6%88%98%E9%80%9F%E5%86%B3/"},{"title":"题目思路存储","text":"奇怪的最短路问题原题：HDU6166/P5304/LOJ#3087 法一维护最短路和次短路以及它们的来源点。具体有待补充。 法二一种套路：多源多汇最短路。 多源多汇怎么做？ 建一个超级源点和超级汇点，但是这样从源点出来就可以0权到汇点。 解决方案： 随机划分： $p=\\frac{1}{4}$，T次成功概率：$1-(1-p)^T$，虽然 $20$ 次随机成功概率为 $99.68\\%$，但毕竟是概率，不够靠谱并且基于RP。 二进制分组： 按照二进制的一个位置上的 $01$ 值来划分谁是源点谁是汇点，由数据范围知最多 $17$ 次划分，每次需要跑两遍。有点卡时限但能过。 指针分析复习指针？ 题目中给的关系实际上是一些边的关系，但是这些边有些限制。 某些边有激活条件，例如一个指针得先指向某个地址之后才能访问。 小模拟，将题目操作转化为代码。 Bellman-ford 思想：不断松弛，在过程中实现 $4$ 种操作并同时维护。 实现思路1：set 维护每个点能到哪些点 实现思路2：状态压缩 关于优化： 基于RP：减少松弛轮数 基于卡常：快读 基于随机化：shuffle+clock() 卡时间 老算法焕发新生。 果国的奇妙旅行带决策的期望。 #define 卡 票 定义 $E(u)$ 表示 $u$ 到终点的期望。 此题目要求在最优策略下到终点的期望抽卡次数，可以发现所谓最优策略就是贪心：如果我抽到的卡走过去的期望 $E(v)$ 较 $E(u)$ 而言减小了，即 $E(u) &gt; E(v)$，那么我们就可以走到 $v$，定义这就是一次成功的决策。 也就是说，如果我抽到的卡能使我的期望减小，那么就走，否则扔掉重来。于是我们的转移就可以分为两种情况：一种是 $v$ 向 $u$ 转移；另一种是不转移。 我们又发现，从结果来看，如果 $u$ 走到 $v$ 这个决策是成功的，那么 $v$ 走到 $u$ 的决策一定是不成功的，因为 $E(u) &gt; E(v)$，就一定 $E(u) &gt; E(v)$ （满篇废话，然而这种显著的废话往往是最难发现并利用的）。 综上，我们就认为 $u$ 的转移是有方向的。 根据以上的情况讨论，不难得到 $E(u)$ 转移如下： $$E(u)=\\sum_{v\\in e(u)}^{E(v) &lt; E(u)}{\\frac{E(v)}{deg(u)}}+\\sum_{v\\in e(u)}^{E(v)\\geq E(u)}{\\frac{E(u)}{deg(u)}}+1$$ 设 $x=\\sum[v\\in e(u) \\And E(v) \\geq E(u)],d=deg(u)$ 化简过程： $$E(u)=\\frac{1}{d}(\\sum_{v\\in e(u)}^{E(v) &lt; E(u)}{E(v)}+xE(u))+1$$ $$dE(u)=\\sum_{v\\in e(u)}^{E(v) &lt; E(u)}{E(v)}+xE(u)+d$$ $$(d-x)E(u)=\\sum_{v\\in e(u)}^{E(v) &lt; E(u)}{E(v)}+d$$ 得到： $$E(u)=\\sum_{v\\in e(u)}^{E(v) &lt; E(u)}{\\frac{E(v)}{d-x}}+\\frac{d}{d-x}$$ 十分抽象的一点是：我确定边的方向需要 $u$ 和 $v$ 的期望来进行大小比较，然而期望又需要边的方向来更新。问题就是如何打破这个循环。 数学上的推导不太可能了，考虑从更新顺序入手。 目前这里的方法是填表法，考虑使用刷表法，即对于每个 $u$ 去更新它的 $v$。考虑使用Dijkstra算法。而且不难发现，$E(u)$ 的值随着更新不断减小（分母变大）。 像这种破逻辑的环很难解决，切入口不好找，因此这里直接放结论。 一开始设置 $E(u)=+\\infty$ ，然后让 $E(v)$ 从小到大更新 $E(u)$ 。 （为什么这样可行我也不会证。可能需要数学归纳法。） 最后，因为 $E(u)$ 的定义是 $u$ 到终点的期望，因此搜索时应该从终点开始搜。（思考：从起点搜结果会受影响吗？） 推完了。 至于怎么实现还得是Dijkstra。 事实上，指针分析 和 果国的奇妙旅行 都不是最短路的题目，但是借用了最短路算法的思想，不愧为《最新颖的一集》。","link":"/2023/12/30/%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E5%AD%98%E5%82%A8/"},{"title":"题解：对称二叉树","text":"思路因为这道题只要求最大的节点数量，所以我们只用枚举“根节点”的位置，然后判断是否对称，如果对称，统计这棵子树的节点数并记录 ans 。cnt 与 main 函数过于简单故不在此处展开赘述，单独看看 same 函数——判断是否对称。我们一次需要两个位置来判断对称，而这两棵子树对称，当且仅当它们的儿子们全部对称，便可以从此处向下递归。递归的两边就是同时向内收 (ls[RootR],rs[RootL]) 或同时向外放 (ls[RootL],rs[RootR])，如果不这样的话遍历的两个位置本身就不对称。基于此，我们再来看实现。 实现在代码实现方面，存树我们使用两个列表 ls 与 rs，这里开成了一个结构体，除此之外，我们还需要一个 id 用于存储树上节点的 value 。其余部分和思路部分所论述的一样。 代码1234567891011121314151617181920212223242526/*头文件及数组略*/bool same(long long x, long long y) { if (x &lt; 0 &amp;&amp; y &lt; 0) return true; // 如果两边遍历到此处均为空，这棵树仍然对称 if (x &lt; 0 || y &lt; 0) return false; // 前面把都为空的情况return了，这里是只有一个点为空的情况 if (t[x].id != t[y].id) return false; // 值不匹配 bool r = same(t[x].ls, t[y].rs)&amp;&amp;same(t[x].rs, t[y].ls); // 递归检查子树是否符合要求 return r; // 略(?)}long long cnt(long long u) { // 简单的节点统计 if (u &lt; 0) return 0; return cnt(t[u].ls)+cnt(t[u].rs)+1;}int main() { /* 输入略 */ for (long long i = 1; i &lt;= n; i++) { if (same(i, i)) { // 如果以i为根的子树对称，统计节点并记录ans ans = max(ans, cnt(i)); } } cout &lt;&lt; ans; return 0; // 结束}","link":"/2023/05/21/%E9%A2%98%E8%A7%A3%EF%BC%9A%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"游记","slug":"游记","link":"/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"解题报告","slug":"解题报告","link":"/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"优化","slug":"优化","link":"/tags/%E4%BC%98%E5%8C%96/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"二分图","slug":"二分图","link":"/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"连通块","slug":"连通块","link":"/tags/%E8%BF%9E%E9%80%9A%E5%9D%97/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"思想","slug":"思想","link":"/tags/%E6%80%9D%E6%83%B3/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"技巧","slug":"技巧","link":"/tags/%E6%8A%80%E5%B7%A7/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"欧拉反演","slug":"欧拉反演","link":"/tags/%E6%AC%A7%E6%8B%89%E5%8F%8D%E6%BC%94/"},{"name":"存储","slug":"存储","link":"/tags/%E5%AD%98%E5%82%A8/"},{"name":"排列组合","slug":"排列组合","link":"/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"},{"name":"乘法逆元","slug":"乘法逆元","link":"/tags/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"},{"name":"背包问题","slug":"背包问题","link":"/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"}],"categories":[{"name":"游记","slug":"游记","link":"/categories/%E6%B8%B8%E8%AE%B0/"},{"name":"解题报告","slug":"解题报告","link":"/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"name":"学习总结","slug":"学习总结","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"动态规划","slug":"学习总结/动态规划","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"考试","slug":"学习总结/考试","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E8%80%83%E8%AF%95/"},{"name":"思想","slug":"学习总结/思想","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E6%80%9D%E6%83%B3/"},{"name":"技巧","slug":"随笔/技巧","link":"/categories/%E9%9A%8F%E7%AC%94/%E6%8A%80%E5%B7%A7/"},{"name":"优化","slug":"随笔/优化","link":"/categories/%E9%9A%8F%E7%AC%94/%E4%BC%98%E5%8C%96/"},{"name":"图论","slug":"学习总结/图论","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%9B%BE%E8%AE%BA/"},{"name":"数学","slug":"学习总结/数学","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"最短路","slug":"学习总结/图论/最短路","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"pages":[]}